{
  "timestamp": "2026-01-12T15:12:59.057399+00:00",
  "value": "# HttpClient Decorator Pattern for .NET\n\n<div align=\"center\">\n\n[![Build and Deploy](https://github.com/markhazleton/HttpClientDecoratorPattern/actions/workflows/main_httpclientdecoratorpattern.yml/badge.svg)](https://github.com/markhazleton/HttpClientDecoratorPattern/actions/workflows/main_httpclientdecoratorpattern.yml)\n[![NuGet](https://img.shields.io/nuget/v/WebSpark.HttpClientUtility.svg)](https://www.nuget.org/packages/WebSpark.HttpClientUtility/)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![.NET Version](https://img.shields.io/badge/.NET-10.0-blue.svg)](https://dotnet.microsoft.com/download)\n\n**Production-ready implementation of the Decorator Pattern for HttpClient with Telemetry, Caching, and Resilience**\n\n[Live Demo](https://httpclientdecoratorpattern.azurewebsites.net/) \u2022 [Documentation](https://markhazleton.com/decorator-pattern-http-client.html) \u2022 [NuGet Package](https://www.nuget.org/packages/WebSpark.HttpClientUtility/)\n\n</div>\n\n---\n\n## \ud83d\udcd6 Table of Contents\n\n- [Overview](#-overview)\n- [Key Features](#-key-features)\n- [Live Demo Pages](#-live-demo-pages)\n- [Architecture](#-architecture)\n- [Quick Start](#-quick-start)\n- [Installation](#-installation)\n- [Usage Examples](#-usage-examples)\n- [WebSpark.HttpClientUtility Package](#-websparkhttpclientutility-package)\n- [Configuration](#-configuration)\n- [API Integration Examples](#-api-integration-examples)\n- [Best Practices](#-best-practices)\n- [Performance Considerations](#-performance-considerations)\n- [Contributing](#-contributing)\n- [License](#-license)\n\n---\n\n## \ud83c\udfaf Overview\n\nThis repository showcases a **production-ready implementation** of the Decorator Design Pattern applied to HttpClient in .NET 10. It demonstrates how to enhance HTTP operations with cross-cutting concerns while maintaining clean, maintainable, and testable code.\n\nThe project serves as both a **reference implementation** and a **live demonstration** of the [WebSpark.HttpClientUtility](https://www.nuget.org/packages/WebSpark.HttpClientUtility/) NuGet package, providing practical examples of how to implement robust HTTP clients in enterprise applications.\n\n### Why This Pattern?\n\nTraditional approaches to adding functionality to HttpClient often result in:\n- \u274c Tightly coupled code\n- \u274c Difficult to test components\n- \u274c Violation of Single Responsibility Principle\n- \u274c Hard-to-maintain implementations\n\nThe Decorator Pattern solves these issues by:\n- \u2705 Adding behavior dynamically without modifying existing code\n- \u2705 Composing functionality through layering\n- \u2705 Adhering to SOLID principles\n- \u2705 Enabling easy testing through dependency injection\n- \u2705 Providing clear separation of concerns\n\n---\n\n## \u2b50 Key Features\n\n### \ud83d\udd0d **Telemetry & Observability**\n- Automatic request/response timing metrics\n- Request and response size tracking\n- Correlation ID propagation for distributed tracing\n- Detailed structured logging with telemetry data\n- Performance monitoring for all HTTP operations\n\n### \u26a1 **Performance Optimization**\n- **Smart Memory Caching**: Configurable cache duration per request\n- **Cache Hit/Miss Tracking**: Monitor cache effectiveness\n- **Response Size Optimization**: Track and analyze payload sizes\n- **Concurrent Request Management**: SemaphoreSlim for controlled parallelism\n\n### \ud83d\udee1\ufe0f **Resilience & Reliability**\n- **Circuit Breaker Pattern**: Prevent cascading failures during service outages\n- **Retry Policies**: Configurable retry with exponential backoff\n- **Timeout Management**: Request-level timeout configuration\n- **Polly Integration**: Full support for Polly resilience policies\n\n### \ud83c\udfa8 **Modern UI & Themes**\n- **Bootswatch Integration**: 26+ Bootstrap themes with live switching\n- **Responsive Design**: Mobile-first, fully responsive interface\n- **Real-time Theme Preview**: Instant theme changes without page reload\n- **Professional Layout**: Clean, modern UI following best practices\n\n### \ud83d\udd27 **Developer Experience**\n- **Clean Architecture**: Clear separation of concerns\n- **Dependency Injection**: Full DI support throughout\n- **Strongly Typed Models**: Type-safe request/response handling\n- **Comprehensive Examples**: Multiple real-world API integrations\n- **Production Ready**: Battle-tested patterns and practices\n\n---\n\n## \ud83c\udf10 Live Demo Pages\n\nThe demonstration application includes several interactive examples:\n\n| Page | Description | Key Features |\n|------|-------------|--------------|\n| **\ud83c\udfad Joke API** | Simple GET request demonstration | Basic API consumption, telemetry tracking |\n| **\ud83c\udfa8 Art Institute** | Complex data retrieval with caching | Image handling, large datasets, cache effectiveness |\n| **\ud83d\ude80 NASA Picture of the Day** | Image API integration | Daily API quota, caching strategies, media handling |\n| **\ud83d\udcca Circuit Breaker** | Resilience pattern demonstration | Failure handling, circuit state management, recovery |\n| **\ud83d\udd04 Concurrent Calls** | Parallel request handling | SemaphoreSlim usage, performance optimization, throttling |\n| **\ud83d\udd77\ufe0f Domain Crawler** | Web crawling with SignalR | Real-time updates, progress tracking, link discovery |\n| **\ud83d\udcda Documentation** | Interactive package documentation | API reference, usage examples, configuration guide |\n\nEach page demonstrates different aspects of the decorator pattern and includes detailed telemetry information showing the benefits of the implementation.\n\n---\n\n## \ud83c\udfd7\ufe0f Architecture\n\n### The Decorator Pattern in Action\n\n```mermaid\ngraph TD\n    A[Client Code] --> B[IHttpRequestResultService]\n    B --> C[Cache Decorator]\n    C --> D[Telemetry Decorator]\n    D --> E[Polly Decorator]\n    E --> F[Base Service]\n    F --> G[HttpClient]\n```\n\n### Core Components\n\n#### 1. **Service Interface** (from WebSpark.HttpClientUtility)\n\n```csharp\npublic interface IHttpRequestResultService\n{\n    Task<HttpRequestResult<T>> HttpSendRequestResultAsync<T>(\n        HttpRequestResult<T> requestResult,\n        CancellationToken ct = default);\n}\n```\n\n#### 2. **Request/Response Container**\n\n```csharp\npublic class HttpRequestResult<T>\n{\n    public string RequestPath { get; set; }                    // API endpoint\n    public T? ResponseResults { get; set; }                    // Parsed response\n    public int CacheDurationMinutes { get; set; }              // Cache TTL\n    public bool IsCached { get; set; }                         // Cache status\n    public TimeSpan RequestDuration { get; set; }              // Request time\n    public long ResponseSizeBytes { get; set; }                // Response size\n    public string CorrelationId { get; set; }                  // Tracking ID\n    public bool IsSuccess { get; set; }                        // Success flag\n    public HttpStatusCode StatusCode { get; set; }             // HTTP status\n    public string? ErrorMessage { get; set; }                  // Error details\n}\n```\n\n#### 3. **Decorator Chain Implementation**\n\nThe decorators are layered in a specific order to maximize effectiveness:\n\n```csharp\nbuilder.Services.AddSingleton<IHttpRequestResultService>(serviceProvider =>\n{\n    // 1. Base Service - Handles actual HTTP communication\n    IHttpRequestResultService baseService = new HttpRequestResultService(\n        serviceProvider.GetRequiredService<ILogger<HttpRequestResultService>>(),\n        serviceProvider.GetRequiredService<IConfiguration>(),\n        serviceProvider.GetRequiredService<IHttpClientFactory>()\n            .CreateClient(\"HttpClientDecorator\")\n    );\n\n    // 2. Polly Decorator - Adds retry and circuit breaker policies\n    var pollyOptions = serviceProvider.GetRequiredService<IConfiguration>()\n        .GetSection(\"HttpRequestResultPollyOptions\")\n        .Get<HttpRequestResultPollyOptions>();\n\n    IHttpRequestResultService pollyService = new HttpRequestResultServicePolly(\n        serviceProvider.GetRequiredService<ILogger<HttpRequestResultServicePolly>>(),\n        baseService,\n        pollyOptions\n    );\n\n    // 3. Telemetry Decorator - Adds performance tracking\n    IHttpRequestResultService telemetryService = new HttpRequestResultServiceTelemetry(\n        serviceProvider.GetRequiredService<ILogger<HttpRequestResultServiceTelemetry>>(),\n        pollyService\n    );\n\n    // 4. Cache Decorator - Adds response caching (outermost layer)\n    IHttpRequestResultService cacheService = new HttpRequestResultServiceCache(\n        telemetryService,\n        serviceProvider.GetRequiredService<ILogger<HttpRequestResultServiceCache>>(),\n        serviceProvider.GetRequiredService<IMemoryCache>()\n    );\n\n    return cacheService; // Return the fully decorated service\n});\n```\n\n### Why This Order Matters\n\n1. **Cache First** (outermost): Check cache before doing any work\n2. **Telemetry Second**: Track all operations, even cached ones\n3. **Polly Third**: Apply resilience policies to actual HTTP calls\n4. **Base Last** (innermost): Execute the actual HTTP request\n\n---\n\n## \ud83d\ude80 Quick Start\n\n### Prerequisites\n\n- **.NET 10 SDK** or later ([Download](https://dotnet.microsoft.com/download/dotnet/10.0))\n- **Visual Studio 2022** (v17.12+) or **Visual Studio Code**\n- **Git** for cloning the repository\n\n### Clone and Run\n\n```bash\n# Clone the repository\ngit clone https://github.com/markhazleton/HttpClientDecoratorPattern.git\n\n# Navigate to the project directory\ncd HttpClientDecoratorPattern\n\n# Restore dependencies\ndotnet restore\n\n# Build the solution\ndotnet build\n\n# Run the web application\ncd HttpClientDecorator.Web\ndotnet run\n\n# Open browser to https://localhost:5001\n```\n\nThe application will launch and be available at `https://localhost:5001` (or the port shown in the console).\n\n---\n\n## \ud83d\udce6 Installation\n\n### Using the NuGet Package in Your Own Projects\n\n#### Via .NET CLI\n```bash\ndotnet add package WebSpark.HttpClientUtility\n```\n\n#### Via Package Manager Console\n```powershell\nInstall-Package WebSpark.HttpClientUtility\n```\n\n#### Via PackageReference (in .csproj)\n```xml\n<PackageReference Include=\"WebSpark.HttpClientUtility\" Version=\"1.0.5\" />\n```\n\n### Additional Dependencies\n\nThe package has minimal dependencies:\n- `Microsoft.Extensions.Caching.Abstractions`\n- `Microsoft.Extensions.Http`\n- `Microsoft.Extensions.Logging.Abstractions`\n- `Polly` (for resilience policies)\n\n---\n\n## \ud83d\udca1 Usage Examples\n\n### Basic Usage\n\n```csharp\npublic class WeatherService\n{\n    private readonly IHttpRequestResultService _httpService;\n\n    public WeatherService(IHttpRequestResultService httpService)\n    {\n        _httpService = httpService;\n    }\n\n    public async Task<WeatherData?> GetWeatherAsync(string city)\n    {\n        var request = new HttpRequestResult<WeatherData>\n        {\n            RequestPath = $\"https://api.weather.com/v3/weather?city={city}\",\n            CacheDurationMinutes = 15 // Cache for 15 minutes\n        };\n\n        var result = await _httpService.HttpSendRequestResultAsync(request);\n\n        if (result.IsSuccess)\n        {\n            Console.WriteLine($\"Request took: {result.RequestDuration.TotalMilliseconds}ms\");\n            Console.WriteLine($\"Cached: {result.IsCached}\");\n            Console.WriteLine($\"Response size: {result.ResponseSizeBytes} bytes\");\n\n            return result.ResponseResults;\n        }\n\n        Console.WriteLine($\"Error: {result.ErrorMessage}\");\n        return null;\n    }\n}\n```\n\n### With Custom Headers\n\n```csharp\nvar request = new HttpRequestResult<ApiResponse>\n{\n    RequestPath = \"https://api.example.com/data\",\n    CacheDurationMinutes = 0, // Don't cache\n    HttpMethod = HttpMethod.Post,\n    RequestBody = JsonSerializer.Serialize(new { query = \"search term\" })\n};\n\n// Custom headers are set up in HttpClient configuration\nvar result = await _httpService.HttpSendRequestResultAsync(request);\n```\n\n### Concurrent Requests with SemaphoreSlim\n\n```csharp\npublic class DataAggregatorService\n{\n    private readonly IHttpRequestResultService _httpService;\n    private readonly SemaphoreSlim _semaphore = new(10, 10); // Max 10 concurrent\n\n    public async Task<List<TResult>> GetMultipleAsync<TResult>(\n        List<string> urls,\n        CancellationToken ct = default)\n    {\n        var tasks = urls.Select(async url =>\n        {\n            await _semaphore.WaitAsync(ct);\n            try\n            {\n                var request = new HttpRequestResult<TResult>\n                {\n                    RequestPath = url,\n                    CacheDurationMinutes = 5\n                };\n\n                var result = await _httpService\n                    .HttpSendRequestResultAsync(request, ct);\n\n                return result.ResponseResults;\n            }\n            finally\n            {\n                _semaphore.Release();\n            }\n        });\n\n        var results = await Task.WhenAll(tasks);\n        return results.Where(r => r != null).ToList()!;\n    }\n}\n```\n\n### Custom Decorator\n\nYou can create your own decorators:\n\n```csharp\npublic class CustomLoggingDecorator : IHttpRequestResultService\n{\n    private readonly IHttpRequestResultService _decoratedService;\n    private readonly ILogger _logger;\n\n    public CustomLoggingDecorator(\n        IHttpRequestResultService decoratedService,\n        ILogger<CustomLoggingDecorator> logger)\n    {\n        _decoratedService = decoratedService;\n        _logger = logger;\n    }\n\n    public async Task<HttpRequestResult<T>> HttpSendRequestResultAsync<T>(\n        HttpRequestResult<T> requestResult,\n        CancellationToken ct = default)\n    {\n        _logger.LogInformation(\n            \"Making request to {Url} at {Time}\",\n            requestResult.RequestPath,\n            DateTime.UtcNow);\n\n        var result = await _decoratedService\n            .HttpSendRequestResultAsync(requestResult, ct);\n\n        _logger.LogInformation(\n            \"Request completed. Success: {Success}, Duration: {Duration}ms\",\n            result.IsSuccess,\n            result.RequestDuration.TotalMilliseconds);\n\n        return result;\n    }\n}\n```\n\n---\n\n## \ud83d\udd27 Configuration\n\n### appsettings.json\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"WebSpark.HttpClientUtility\": \"Information\"\n    }\n  },\n  \"HttpRequestResultPollyOptions\": {\n    \"RetryCount\": 3,\n    \"RetryDelayMilliseconds\": 1000,\n    \"CircuitBreakerFailureThreshold\": 5,\n    \"CircuitBreakerSamplingDurationSeconds\": 60,\n    \"CircuitBreakerMinimumThroughput\": 10,\n    \"CircuitBreakerDurationOfBreakSeconds\": 30,\n    \"TimeoutSeconds\": 30\n  },\n  \"AllowedHosts\": \"*\"\n}\n```\n\n### HttpClient Configuration\n\n```csharp\nbuilder.Services.AddHttpClient(\"HttpClientDecorator\", client =>\n{\n    client.Timeout = TimeSpan.FromSeconds(30);\n    client.DefaultRequestHeaders.Add(\"Accept\", \"application/json\");\n    client.DefaultRequestHeaders.Add(\"User-Agent\", \"YourAppName/1.0\");\n    client.DefaultRequestHeaders.Add(\"X-Request-Source\", \"YourAppName\");\n})\n.ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler\n{\n    AllowAutoRedirect = true,\n    MaxAutomaticRedirections = 10,\n    AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate\n});\n```\n\n---\n\n## \ud83d\udd0c API Integration Examples\n\nThis project demonstrates integration with several public APIs:\n\n### 1. JokeAPI (v2.jokeapi.dev)\n- **Purpose**: Demonstrate simple GET requests with telemetry\n- **Features**: Safe-mode jokes, multiple joke types\n- **Cache Strategy**: No caching (fresh jokes each time)\n\n### 2. Art Institute of Chicago API\n- **Purpose**: Complex data structures and image handling\n- **Features**: Pagination, image URLs, metadata\n- **Cache Strategy**: 30-minute cache for artwork data\n\n### 3. NASA Astronomy Picture of the Day (APOD)\n- **Purpose**: Media handling and daily content\n- **Features**: Image URLs, descriptions, dates\n- **Cache Strategy**: 24-hour cache (updates daily)\n\n### 4. Custom Circuit Breaker Test Endpoint\n- **Purpose**: Demonstrate resilience patterns\n- **Features**: Controlled failures, circuit state visualization\n- **Cache Strategy**: No caching (testing resilience)\n\n---\n\n## \ud83c\udfaf Best Practices\n\n### \u2705 DO\n\n1. **Use appropriate cache durations** based on data freshness requirements\n2. **Set reasonable timeouts** to prevent hanging requests\n3. **Implement proper cancellation token handling** for responsive applications\n4. **Monitor telemetry data** to identify performance bottlenecks\n5. **Use SemaphoreSlim** for controlling concurrent API calls\n6. **Configure circuit breakers** based on your API's characteristics\n7. **Log correlation IDs** for distributed tracing\n8. **Handle errors gracefully** and provide meaningful error messages\n\n### \u274c DON'T\n\n1. **Don't cache error responses** - let failures fail fast\n2. **Don't ignore cancellation tokens** - respect user cancellations\n3. **Don't use overly aggressive retry policies** - respect API rate limits\n4. **Don't cache sensitive data** without encryption\n5. **Don't ignore HTTP status codes** - handle different scenarios appropriately\n6. **Don't create new HttpClient instances** per request - use IHttpClientFactory\n7. **Don't forget to dispose** of resources properly\n8. **Don't hardcode configuration** - use appsettings.json\n\n---\n\n## \ud83d\udcca Performance Considerations\n\n### Memory Usage\n\n- **Cache Size**: Monitor memory cache size and set appropriate eviction policies\n- **Response Objects**: Large responses impact memory; consider streaming for large payloads\n- **Concurrent Requests**: Each request consumes memory; use SemaphoreSlim to limit concurrency\n\n### Optimization Tips\n\n1. **Cache Effectively**\n   ```csharp\n   // Cache frequently accessed, slowly changing data\n   request.CacheDurationMinutes = 60; // 1 hour for stable data\n\n   // Don't cache dynamic data\n   request.CacheDurationMinutes = 0; // Real-time data\n   ```\n\n2. **Use Compression**\n   ```csharp\n   AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate\n   ```\n\n3. **Limit Concurrent Requests**\n   ```csharp\n   private readonly SemaphoreSlim _semaphore = new(20, 20); // Max 20 concurrent\n   ```\n\n4. **Set Appropriate Timeouts**\n   ```csharp\n   client.Timeout = TimeSpan.FromSeconds(30); // Prevent hanging\n   ```\n\n### Monitoring Metrics\n\nTrack these key performance indicators:\n- **Request Duration**: Average, P95, P99 response times\n- **Cache Hit Rate**: Percentage of requests served from cache\n- **Error Rate**: Failed requests / Total requests\n- **Circuit Breaker State**: Open/Closed/Half-Open states\n- **Response Sizes**: Track bandwidth usage\n\n---\n\n## \ud83e\udd1d Contributing\n\nWe welcome contributions! Here's how you can help:\n\n### Reporting Issues\n\nFound a bug or have a feature request? Please [open an issue](https://github.com/markhazleton/HttpClientDecoratorPattern/issues/new) with:\n- Clear description of the issue\n- Steps to reproduce\n- Expected vs actual behavior\n- Environment details (.NET version, OS, etc.)\n- Screenshots if applicable\n\n### Pull Requests\n\n1. **Fork** the repository\n2. **Create** a feature branch (`git checkout -b feature/amazing-feature`)\n3. **Make** your changes\n4. **Test** thoroughly (add unit tests if applicable)\n5. **Commit** with clear messages (`git commit -m 'Add amazing feature'`)\n6. **Push** to your fork (`git push origin feature/amazing-feature`)\n7. **Open** a Pull Request\n\nPlease ensure:\n- \u2705 Code follows existing style conventions\n- \u2705 All tests pass\n- \u2705 Documentation is updated\n- \u2705 Commit messages are descriptive\n\nSee [CONTRIBUTING.md](CONTRIBUTING.md) for detailed guidelines.\n\n---\n\n## \ud83d\udcda Additional Resources\n\n### Documentation\n- [Blog Post: Decorator Pattern for HttpClient](https://markhazleton.com/decorator-pattern-http-client.html)\n- [WebSpark.HttpClientUtility on NuGet](https://www.nuget.org/packages/WebSpark.HttpClientUtility/)\n- [Live Demo Application](https://httpclientdecoratorpattern.azurewebsites.net/)\n\n### Related Patterns\n- [Decorator Pattern (Gang of Four)](https://refactoring.guru/design-patterns/decorator)\n- [Circuit Breaker Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker)\n- [Retry Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry)\n\n### Microsoft Documentation\n- [IHttpClientFactory](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests)\n- [Polly Resilience Framework](https://github.com/App-vNext/Polly)\n- [.NET Dependency Injection](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection)\n\n---\n\n## \ud83c\udfc6 Project Stats\n\n- **Built with**: .NET 10.0 LTS\n- **Language**: C# 13\n- **Architecture**: ASP.NET Core Razor Pages\n- **Pattern**: Decorator Pattern (GoF)\n- **Hosting**: Azure App Service\n- **CI/CD**: GitHub Actions\n- **Testing**: Real-world API integrations\n\n---\n\n## \ud83d\udcc4 License\n\nThis project is licensed under the **MIT License** - see the [LICENSE](LICENSE) file for details.\n\n```\nMIT License\n\nCopyright (c) 2024 Mark Hazleton\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n```\n\n---\n\n## \ud83d\udc64 Author\n\n**Mark Hazleton**\n\n- Website: [markhazleton.com](https://markhazleton.com)\n- GitHub: [@markhazleton](https://github.com/markhazleton)\n- LinkedIn: [Mark Hazleton](https://www.linkedin.com/in/markhazleton/)\n\n---\n\n## \ud83c\udf1f Show Your Support\n\nIf this project helped you, please consider:\n\n- \u2b50 **Starring** the repository\n- \ud83d\udc1b **Reporting issues** you encounter\n- \ud83d\udca1 **Suggesting new features**\n- \ud83d\udce2 **Sharing** with others who might benefit\n- \ud83e\udd1d **Contributing** to make it even better\n\n---\n\n## \ud83d\udd04 Project Status\n\n\u2705 **Actively Maintained** - This project is under active development and maintenance.\n\n- Regular updates for new .NET versions\n- Security patches applied promptly\n- Feature enhancements based on community feedback\n- Bug fixes and improvements ongoing\n\n**Latest Update**: January 2026 - Upgraded to .NET 10.0 LTS\n\n---\n\n<div align=\"center\">\n\n**[\u2b06 Back to Top](#httpclient-decorator-pattern-for-net)**\n\nMade with \u2764\ufe0f by [Mark Hazleton](https://markhazleton.com)\n\n</div>\n",
  "hash": "809e09611bece37d8fcfc6a12fd5c949d50d40b82af115c5b3402295b58bbf0e",
  "metadata": {
    "repository": {
      "owner": "markhazleton",
      "name": "HttpClientDecoratorPattern"
    },
    "category": "readme",
    "pushed_at": "2026-01-12T05:40:31+00:00",
    "ttl_enforced": false
  },
  "category": "readme",
  "owner": "markhazleton",
  "repo": "HttpClientDecoratorPattern",
  "week": "2026-01-12T05-40-31+00-00"
}