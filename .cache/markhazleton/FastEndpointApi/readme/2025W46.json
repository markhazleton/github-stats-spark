{
  "timestamp": "2026-01-04T21:55:32.839806+00:00",
  "value": "# FastEndpoints: A Developer's Guide\n\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\nWelcome to this hands-on exploration of [FastEndpoints](https://fast-endpoints.com/)! If you're looking to streamline your ASP.NET Core API development while maintaining high performance, you're in the right place.\n\nThis guide introduces you to the FastEndpoints framework through a practical Person Management demo application. By walking through this project, you'll discover how FastEndpoints can help you build clean, maintainable APIs with minimal boilerplate code.\n\n**Author**: Mark Hazleton  \n**Article**: [Taking FastEndpoints For a Test Drive](https://markhazleton.com/articles/taking-fastendpoints-for-a-test-drive.html)\n\n## Table of Contents\n\n- [FastEndpoints: A Developer's Guide](#fastendpoints-a-developers-guide)\n  - [Table of Contents](#table-of-contents)\n  - [What is FastEndpoints?](#what-is-fastendpoints)\n  - [Key Features](#key-features)\n  - [Project Structure](#project-structure)\n  - [Getting Started](#getting-started)\n    - [Prerequisites](#prerequisites)\n    - [Running the Project](#running-the-project)\n  - [API Endpoints](#api-endpoints)\n  - [Implementation Details](#implementation-details)\n    - [Data Seeding](#data-seeding)\n    - [Basic Configuration](#basic-configuration)\n    - [Endpoint Implementation](#endpoint-implementation)\n      - [Create Person](#create-person)\n      - [Read Person by ID](#read-person-by-id)\n      - [Read All Persons](#read-all-persons)\n      - [Update Person](#update-person)\n      - [Delete Person](#delete-person)\n    - [Request and Response Models](#request-and-response-models)\n    - [Mapping with FastEndpoints](#mapping-with-fastendpoints)\n    - [Service Layer](#service-layer)\n  - [Advanced Usage](#advanced-usage)\n    - [HATEOAS Implementation](#hateoas-implementation)\n    - [Error Handling](#error-handling)\n  - [Static HTML Sample Pages](#static-html-sample-pages)\n    - [index.html](#indexhtml)\n    - [docs.html](#docshtml)\n    - [test.html](#testhtml)\n  - [Why Use FastEndpoints?](#why-use-fastendpoints)\n  - [Contact \\& Support](#contact--support)\n  - [Additional Resources](#additional-resources)\n  - [Glossary of Terms](#glossary-of-terms)\n  - [Continuous Integration \\& Deployment (CI/CD)](#continuous-integration--deployment-cicd)\n  - [Visual Demo: Interactive Web UI](#visual-demo-interactive-web-ui)\n\n## What is FastEndpoints?\n\nFastEndpoints is a lightweight REST API framework for ASP.NET that implements the REPR (Request-Endpoint-Response) Pattern. It's designed to be a developer-friendly alternative to Minimal APIs and MVC Controllers, significantly reducing boilerplate code while maintaining high performance.\n\nIn this guide, we'll explore a simple Person Management API that demonstrates the power and simplicity of FastEndpoints. You'll see firsthand how this framework encourages clean separation of concerns and implements modern API practices like HATEOAS, making your code more maintainable and your APIs more user-friendly.\n\n## Key Features\n\nThis demo project is designed to showcase FastEndpoints in action through a simple yet comprehensive person management API. Here's what you'll find:\n\n- **CRUD Operations**: Complete set of endpoints for creating, reading, updating, and deleting Person entities\n- **In-Memory Data Store**: A simple in-memory collection to demonstrate data persistence without database complexity\n- **Person Service Layer**: A clean abstraction of business logic through service interfaces and implementations\n- **Smart Data Mapping**: Built-in mapping capabilities for transforming between request models, domain entities, and response DTOs\n- **Dependency Injection**: Practical examples of how DI is used in FastEndpoints to provide services where needed\n- **Reusable Base Classes**: Demonstrations of how to create base endpoint classes to promote code reuse\n- **HATEOAS Links**: Implementation of hypermedia links in API responses for improved client navigation\n- **Interactive Documentation**: Integration with Swagger/OpenAPI for easy API exploration and testing\n\nEach feature is implemented in a straightforward way, making it easy to understand and adapt to your own projects.\n\n## Project Structure\n\nThe demo project follows a clean, organized structure that aligns with the REPR pattern. Let's look at how the files are organized:\n\n```plaintext\nFastEndpointApi/\n\u251c\u2500\u2500 Program.cs                       # Application entry point and configuration\n\u251c\u2500\u2500 endpoints/                       # All API endpoints\n\u2502   \u251c\u2500\u2500 LinkResource.cs              # HATEOAS link representation\n\u2502   \u251c\u2500\u2500 PersonResponse.cs            # Shared response DTO\n\u2502   \u251c\u2500\u2500 create/                      # Create person endpoint\n\u2502   \u2502   \u251c\u2500\u2500 CreatePersonEndpoint.cs\n\u2502   \u2502   \u251c\u2500\u2500 CreatePersonMapper.cs\n\u2502   \u2502   \u2514\u2500\u2500 CreatePersonRequest.cs\n\u2502   \u251c\u2500\u2500 read/                        # Read person endpoint(s)\n\u2502   \u2502   \u251c\u2500\u2500 ReadPersonEndpoint.cs\n\u2502   \u2502   \u251c\u2500\u2500 ReadPersonMapper.cs\n\u2502   \u2502   \u251c\u2500\u2500 ReadPersonRequest.cs\n\u2502   \u2502   \u2514\u2500\u2500 ReadPersonsEndpoint.cs\n\u2502   \u251c\u2500\u2500 update/                      # Update person endpoint\n\u2502   \u2502   \u251c\u2500\u2500 UpdatePersonEndpoint.cs\n\u2502   \u2502   \u2514\u2500\u2500 UpdatePersonRequest.cs\n\u2502   \u2514\u2500\u2500 delete/                      # Delete person endpoint\n\u2502       \u251c\u2500\u2500 DeletePersonEndpoint.cs\n\u2502       \u2514\u2500\u2500 DeletePersonRequest.cs\n\u251c\u2500\u2500 services/                        # Business logic layer\n\u2502   \u251c\u2500\u2500 IPersonService.cs            # Service interface\n\u2502   \u251c\u2500\u2500 PersonEntity.cs              # Domain model\n\u2502   \u2514\u2500\u2500 PersonService.cs             # Service implementation\n\u251c\u2500\u2500 wwwroot/                         # Static web assets\n\u2502   \u251c\u2500\u2500 index.html                   # Interactive web UI\n\u2502   \u251c\u2500\u2500 docs.html                    # API documentation sample page\n\u2502   \u2514\u2500\u2500 test.html                    # Simple test page\n\u2514\u2500\u2500 ...\n```\n\nThis structure promotes separation of concerns, with each endpoint having its own dedicated folder containing all related files. The `wwwroot` folder contains standalone HTML pages for demo and documentation purposes, making it easy to explore and test the API visually.\n\n## Getting Started\n\nReady to dive in? Let's get this demo project up and running on your machine!\n\n### Prerequisites\n\nBefore you begin, make sure you have:\n\n- **.NET 9.0 SDK** or later installed on your machine\n- An IDE of your choice: **Visual Studio**, **VS Code**, or **Rider**\n\n### Running the Project\n\nFollow these simple steps to get the project running:\n\n1. Clone this repository to your local machine:\n\n   ```bash\n   git clone https://github.com/MarkHazleton/FastEndpointDemo.git\n   cd FastEndpointDemo\n   ```\n\n2. Build and run the project:\n\n   ```bash\n   cd FastEndpointApi\n   dotnet build\n   dotnet run\n   ```\n\n3. Open your browser and navigate to `https://localhost:7000/swagger` to explore the API using the interactive Swagger UI.\n\nOnce the application is running, you can use Swagger to test all the endpoints without needing any additional tools. This makes it easy to understand how the API works and how the different parts interact.\n\n## API Endpoints\n\nLet's explore the available endpoints in our Person Management API:\n\n| Method | Endpoint         | Description            |\n|--------|-----------------|------------------------|\n| POST   | `/person`       | Create a new person    |\n| GET    | `/person/{id}`  | Get a person by ID     |\n| GET    | `/person`       | Get all persons        |\n| PUT    | `/person/{id}`  | Update a person        |\n| DELETE | `/person/{id}`  | Delete a person        |\n\nWhen you run the application and navigate to the Swagger UI, you'll be able to test each of these endpoints interactively. This makes it easy to understand how the API works and see the HATEOAS links in action.\n\n## Implementation Details\n\nLet's dive into how this API is built using FastEndpoints. Understanding these patterns will help you quickly adapt the concepts to your own projects.\n\n### Data Seeding\n\nOn startup, the application seeds 5 unique people using the [Bogus](https://github.com/bchavez/Bogus) library. This provides sample data for immediate testing and exploration.\n\n### Basic Configuration\n\nFastEndpoints is configured in the `Program.cs` file:\n\n```csharp\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddFastEndpoints();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.SwaggerDocument(o =>\n{\n    o.ShortSchemaNames = true;\n    o.DocumentSettings = s =>\n    {\n        s.DocumentName = \"v1\";\n    };\n});\nbuilder.Services.AddSingleton<IPersonService, PersonService>();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n}\n\napp.UseExceptionHandler(errorApp =>\n{\n    errorApp.Run(async context =>\n    {\n        context.Response.StatusCode = 500;\n        context.Response.ContentType = \"application/json\";\n        var error = context.Features.Get<Microsoft.AspNetCore.Diagnostics.IExceptionHandlerFeature>()?.Error;\n        await context.Response.WriteAsJsonAsync(new { error = error?.Message ?? \"An error occurred.\" });\n    });\n});\n\napp.UseFastEndpoints(c =>\n{\n    c.Endpoints.ShortNames = true;\n});\napp.UseSwaggerGen();\napp.UseSwaggerUi();\n```\n\n### Endpoint Implementation\n\n#### Create Person\n\n```csharp\npublic class CreatePersonEndpoint(IPersonService _personService) : Endpoint<CreatePersonRequest, PersonResponse, CreatePersonMapper>\n{\n    public override void Configure()\n    {\n        Post(\"/person\");\n        AllowAnonymous();\n    }\n\n    public override Task HandleAsync(CreatePersonRequest req, CancellationToken ct)\n    {\n        PersonEntity entity = Map.ToEntity(req);\n        entity = _personService.CreatePerson(entity);\n        Response = Map.FromEntity(entity);\n        return SendAsync(Response, cancellation: ct);\n    }\n}\n```\n\n#### Read Person by ID\n\n```csharp\npublic class ReadPersonEndpoint(IPersonService personService) : Endpoint<ReadPersonRequest, PersonResponse>\n{\n    public override void Configure()\n    {\n        Get(\"/person/{id}\");\n        AllowAnonymous();\n    }\n\n    public override Task HandleAsync(ReadPersonRequest req, CancellationToken ct)\n    {\n        var person = personService.ReadPerson(req.Id);\n        if (person == null)\n            return SendNotFoundAsync(cancellation: ct);\n        var baseUrl = HttpContext.Request.GetDisplayUrl();\n        Response = new PersonResponse\n        {\n            FullName = $\"{person.FirstName} {person.LastName}\",\n            IsOver18 = person.Age > 18,\n            PersonId = person.Id.ToString(),\n            Links =\n                [\n                    new LinkResource { Rel = \"self\", Href = $\"{baseUrl}/{person.Id}\", Method = \"GET\" },\n                    new LinkResource { Rel = \"delete\", Href = $\"{baseUrl}/{person.Id}\", Method = \"DELETE\" }\n                ]\n        };\n        return SendAsync(Response, cancellation: ct);\n    }\n}\n```\n\n#### Read All Persons\n\n```csharp\npublic class ReadPersonsEndpoint(IPersonService personService) : EndpointWithoutRequest<List<PersonResponse>>\n{\n    public override void Configure()\n    {\n        Get(\"/person\");\n        AllowAnonymous();\n    }\n\n    public override async Task HandleAsync(CancellationToken ct)\n    {\n        var baseUrl = HttpContext.Request.GetDisplayUrl();\n        var personResponses = personService.ReadPersons()\n            .Select(person => new PersonResponse\n            {\n                FullName = $\"{person.FirstName} {person.LastName}\",\n                IsOver18 = person.Age > 18,\n                PersonId = person.Id.ToString(),\n                Links =\n                [\n                    new LinkResource { Rel = \"self\", Href = $\"{baseUrl}/{person.Id}\", Method = \"GET\" },\n                    new LinkResource { Rel = \"delete\", Href = $\"{baseUrl}/{person.Id}\", Method = \"DELETE\" }\n                ]\n            })\n            .ToList();\n        await SendAsync(personResponses, cancellation: ct);\n    }\n}\n```\n\n#### Update Person\n\n```csharp\npublic class UpdatePersonEndpoint(IPersonService personService) : Endpoint<UpdatePersonRequest, PersonResponse>\n{\n    public override void Configure()\n    {\n        Put(\"/person/{id}\");\n        AllowAnonymous();\n    }\n\n    public override Task HandleAsync(UpdatePersonRequest req, CancellationToken ct)\n    {\n        var person = personService.UpdatePerson(req.Id.ToString(), new PersonEntity\n        {\n            FirstName = req.FirstName,\n            LastName = req.LastName,\n            Age = req.Age,\n            Email = req.Email\n        });\n        if (person == null)\n            return SendNotFoundAsync(cancellation: ct);\n        Response = new PersonResponse\n        {\n            FullName = $\"{person.FirstName} {person.LastName}\",\n            IsOver18 = person.Age > 18,\n            PersonId = person.Id.ToString()\n        };\n        return SendAsync(Response, cancellation: ct);\n    }\n}\n```\n\n#### Delete Person\n\n```csharp\npublic class DeletePersonEndpoint : EndpointWithoutRequest\n{\n    private readonly IPersonService _personService;\n    public DeletePersonEndpoint(IPersonService personService)\n    {\n        _personService = personService;\n    }\n    public override void Configure()\n    {\n        Delete(\"/person/{id}\");\n        AllowAnonymous();\n    }\n    public override Task HandleAsync(CancellationToken ct)\n    {\n        var personId = Route<string>(\"Id\");\n        if (_personService.DeletePerson(personId))\n            return SendNoContentAsync(cancellation: ct);\n        else\n            return SendNotFoundAsync(cancellation: ct);\n    }\n}\n```\n\n### Request and Response Models\n\n```csharp\npublic class CreatePersonRequest\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n    public int Age { get; set; }\n    public string Email { get; set; }\n}\n\npublic class UpdatePersonRequest : CreatePersonRequest\n{\n    public string Id { get; set; } = string.Empty;\n}\n\npublic class ReadPersonRequest\n{\n    public string Id { get; set; } = string.Empty;\n}\n\npublic class PersonResponse\n{\n    public string FullName { get; set; }\n    public bool IsOver18 { get; set; }\n    public string PersonId { get; internal set; }\n    public List<LinkResource> Links { get; set; } = [];\n}\n\npublic class LinkResource\n{\n    public string Rel { get; set; }\n    public string Href { get; set; }\n    public string Method { get; set; }\n}\n```\n\n### Mapping with FastEndpoints\n\nOne of the most powerful features of FastEndpoints is its built-in mapping capabilities. Instead of using a separate mapping library, FastEndpoints provides a simple way to define mappings between your request models, domain entities, and response models:\n\n```csharp\n// From FastEndpointApi/endpoints/create/CreatePersonMapper.cs\npublic class CreatePersonMapper : Mapper<CreatePersonRequest, PersonResponse, PersonEntity>\n{\n    public override PersonEntity ToEntity(CreatePersonRequest r) => new()\n    {\n        Id = Guid.NewGuid(),\n        FirstName = r.FirstName,\n        LastName = r.LastName,\n        Age = r.Age,\n        Email = r.Email\n    };\n\n    public override PersonResponse FromEntity(PersonEntity e) => new()\n    {\n        FullName = $\"{e.FirstName} {e.LastName}\",\n        IsOver18 = e.Age >= 18,\n        PersonId = e.Id.ToString()\n    };\n}\n```\n\n### Service Layer\n\nFollowing good design principles, this demo separates business logic into a service layer. The service layer manages person entities with a simple in-memory store:\n\n```csharp\n// From FastEndpointApi/services/PersonService.cs\npublic class PersonService : IPersonService\n{\n    private readonly List<PersonEntity> _people = new();\n    public PersonService()\n    {\n        // Seed 5 unique people using Bogus\n        var faker = new Faker<PersonEntity>()\n            .RuleFor(p => p.Id, f => Guid.NewGuid())\n            .RuleFor(p => p.FirstName, f => f.Name.FirstName())\n            .RuleFor(p => p.LastName, f => f.Name.LastName())\n            .RuleFor(p => p.Age, f => f.Random.Int(18, 80))\n            .RuleFor(p => p.Email, (f, p) => f.Internet.Email(p.FirstName, p.LastName));\n        _people.AddRange(faker.Generate(5));\n    }\n    public PersonEntity CreatePerson(PersonEntity person)\n    {\n        _people.Add(person);\n        return person;\n    }\n    public bool DeletePerson(string? id)\n    {\n        if (id == null) return false;\n        if (Guid.TryParse(id, out Guid guid))\n        {\n            var person = _people.FirstOrDefault(p => p.Id == guid);\n            if (person != null)\n            {\n                _people.Remove(person);\n                return true;\n            }\n        }\n        return false;\n    }\n    public PersonEntity? ReadPerson(string id)\n    {\n        if (Guid.TryParse(id, out Guid guid))\n            return _people.FirstOrDefault(p => p.Id == guid);\n        return null;\n    }\n    public List<PersonEntity> ReadPersons() => _people.ToList();\n    public PersonEntity? UpdatePerson(string id, PersonEntity updatedPerson)\n    {\n        if (Guid.TryParse(id, out Guid guid))\n        {\n            var person = _people.FirstOrDefault(p => p.Id == guid);\n            if (person != null)\n            {\n                var updated = new PersonEntity\n                {\n                    Id = person.Id,\n                    FirstName = updatedPerson.FirstName,\n                    LastName = updatedPerson.LastName,\n                    Age = updatedPerson.Age,\n                    Email = updatedPerson.Email\n                };\n                _people.Remove(person);\n                _people.Add(updated);\n                return updated;\n            }\n        }\n        return null;\n    }\n}\n```\n\n## Advanced Usage\n\nOnce you've mastered the basics, FastEndpoints offers several advanced features that can enhance your API. Let's explore a couple of them implemented in this demo.\n\n### HATEOAS Implementation\n\nHATEOAS (Hypermedia as the Engine of Application State) improves API discoverability by including relevant links in responses. This demo shows how easy it is to implement with FastEndpoints:\n\n```csharp\n// From FastEndpointApi/endpoints/read/ReadPersonEndpoint.cs\nResponse = new PersonResponse\n{\n    FullName = $\"{person.FirstName} {person.LastName}\",\n    IsOver18 = person.Age > 18,\n    PersonId = person.Id.ToString(),\n    Links =\n        [\n            new LinkResource { Rel = \"self\", Href = $\"{baseUrl}/{person.Id}\", Method = \"GET\" },\n            new LinkResource { Rel = \"delete\", Href = $\"{baseUrl}/{person.Id}\", Method = \"DELETE\" }\n        ]\n};\n```\n\nBy including these links, clients can dynamically discover available actions rather than having to know them in advance. This makes your API more self-documenting and flexible.\n\n### Error Handling\n\nWell-designed APIs need robust error handling. This demo project implements a global exception handler that provides consistent, client-friendly error responses:\n\n```csharp\n// From FastEndpointApi/Program.cs\napp.UseExceptionHandler(errorApp =>\n{\n    errorApp.Run(async context =>\n    {\n        context.Response.StatusCode = 500;\n        context.Response.ContentType = \"application/json\";\n        var error = context.Features.Get<Microsoft.AspNetCore.Diagnostics.IExceptionHandlerFeature>()?.Error;\n        await context.Response.WriteAsJsonAsync(new { error = error?.Message ?? \"An error occurred.\" });\n    });\n});\n```\n\nThis approach ensures that even unexpected exceptions are caught and returned in a consistent JSON format, improving the API's reliability and developer experience. FastEndpoints also provides additional error handling capabilities through its validation features, which aren't shown in this snippet but are documented in the FastEndpoints documentation.\n\n## Static HTML Sample Pages\n\nThe `wwwroot` folder contains several standalone HTML pages that demonstrate and document the API. These are plain, easy-to-follow HTML files that require no build tools or frameworks\u2014just open them in your browser.\n\n### index.html\n\nThe main interactive web UI for the Person API. This page provides a user-friendly way to:\n\n- Create a new person\n- View all people in the system\n- Get a person by ID\n- Update a person's details\n- Delete a person\n- Quickly access Swagger UI and the related article\n\nThe UI is built with Bootstrap for a clean, responsive look and uses JavaScript to call the API endpoints directly. This makes it easy to test all CRUD operations and see HATEOAS links in action. The code is simple and well-commented, making it easy to follow and adapt.\n\n### docs.html\n\nA sample documentation page that demonstrates how to present API documentation or usage instructions in a clean, readable format. This page is a plain HTML file and can be used as a template for your own API documentation. It is easy to modify and extend, and serves as a quick reference for API consumers.\n\n### test.html\n\nA minimal test page for quickly verifying API connectivity or experimenting with JavaScript fetch calls. This file is intentionally simple, making it a great starting point for learning how to interact with the API using plain JavaScript. You can use it to test endpoints or as a base for your own experiments.\n\nAll these pages are self-contained and require no dependencies\u2014just open them in your browser and start exploring.\n\n## Why Use FastEndpoints?\n\nIf you're wondering whether FastEndpoints is right for your project, consider these advantages over traditional MVC Controllers and even Minimal APIs:\n\n- **Clean Architecture**: Promotes the REPR pattern for organized, maintainable code\n- **Performance**: Comparable to Minimal APIs and faster than MVC Controllers\n- **Reduced Boilerplate**: Simplified endpoint creation with minimal setup code\n- **Auto-Discovery**: Automatic registration of endpoints during application startup\n- **Built-in Validation**: Seamless integration with FluentValidation\n- **Security Support**: Easy implementation of authentication and authorization\n- **Swagger Integration**: Simple API documentation with the FastEndPoints.Swagger package\n\nBy adopting FastEndpoints, you'll find that your API development becomes more streamlined, allowing you to focus on business logic rather than plumbing code.\n\n## Contact & Support\n\nHave questions or encountered an issue? Feel free to [create an issue](https://github.com/MarkHazleton/FastEndpointDemo/issues) on the GitHub repository.\n\n## Additional Resources\n\nWant to learn more? Check out these valuable resources:\n\n- [Official FastEndPoints Documentation](https://fast-endpoints.com/)\n- [FastEndPoints GitHub Repository](https://github.com/FastEndpoints/FastEndpoints)\n- [NuGet Package](https://www.nuget.org/packages/FastEndpoints/)\n- [Swagger Support](https://www.nuget.org/packages/FastEndpoints.Swagger/)\n\n## Glossary of Terms\n\nNew to RESTful APIs or .NET development? Here's a handy glossary of terms used in this project:\n\n- **REPR Pattern**: Request-Endpoint-Response Pattern - An architectural approach where each endpoint has its own request model, handler, and response model, promoting separation of concerns.\n\n- **DTO**: Data Transfer Object - A simple object used to transfer data between processes or layers of an application.\n\n- **REST**: Representational State Transfer - An architectural style for designing networked applications, emphasizing stateless operations and standard HTTP methods.\n\n- **HATEOAS**: Hypermedia as the Engine of Application State - A REST constraint that provides hyperlinks in API responses, allowing clients to dynamically navigate the API.\n\n- **Swagger/OpenAPI**: A specification and set of tools for documenting and exploring RESTful APIs.\n\n- **Endpoint**: In the context of APIs, an endpoint is a specific URL where your service can be accessed by a client application.\n\n- **Dependency Injection (DI)**: A technique where one object supplies the dependencies of another object, helping to achieve loose coupling between classes.\n\n- **Mapper**: A component that transforms data from one object type to another, often used to convert between DTOs and domain entities.\n\n- **Entity**: A class that represents a domain model and typically maps to a database table in ORM scenarios.\n\n- **Minimal API**: A simplified approach in ASP.NET Core for building HTTP APIs with minimal dependencies and setup.\n\n- **Fluent Validation**: A library for building validation rules using a fluent interface.\n\n- **NuGet Package**: The package manager for .NET that simplifies the process of incorporating third-party libraries into a project.\n\n- **ASP.NET Core**: A cross-platform, high-performance framework for building modern, cloud-based, internet-connected applications.\n\nThis glossary should help junior developers better understand the concepts used throughout this project and in modern API development more broadly.\n\n## Continuous Integration & Deployment (CI/CD)\n\nThis project uses GitHub Actions to automate building, testing, and deploying the ASP.NET Core application to Azure Web Apps. The workflow is defined in `.github/workflows/main_fastendpointsdemo.yml` and includes:\n\n- **Automatic Build & Test**: On every push to the `main` branch, the workflow restores dependencies, builds the project, and runs tests.\n- **Artifact Publishing**: The build output is published and uploaded as an artifact for deployment.\n- **Azure Web App Deployment**: The application is deployed to Azure using the official `azure/webapps-deploy` action, with secure authentication via OIDC.\n- **Post-Deployment Health Check**: After deployment, the workflow performs a health check on the live site to verify successful deployment.\n\nThis ensures that every change to the `main` branch is automatically validated and deployed, providing a robust DevOps pipeline for the demo application.\n\n## Visual Demo: Interactive Web UI\n\nA modern, interactive web UI is included with the demo and can be accessed at `/index.html` (served from `wwwroot/index.html`). This page provides a user-friendly way to explore and interact with the Person API without needing external tools.\n\n**Features:**\n\n- **Create Person:** Fill out a form to add a new person to the in-memory data store.\n- **Get All People:** View a table of all people currently in the system.\n- **Get Person by ID:** Retrieve and display a person's details and HATEOAS links by entering their ID.\n- **Update Person:** Update an existing person's details using their ID.\n- **Delete Person:** Remove a person from the system by ID.\n- **Swagger & Article Links:** Quick access to the Swagger UI and the related article.\n\nThe UI is built with Bootstrap for a clean, responsive look and uses JavaScript to call the API endpoints directly. This makes it easy to test all CRUD operations and see HATEOAS links in action.\n\n> **Tip:** The web UI is a great way to demo the API to others or to quickly verify functionality during development.\n",
  "hash": "632eb6879d6d9538f49f0cd2fe3d8a9305258c062adf9d60fdb5f5e0835d0067",
  "metadata": {
    "repository": {
      "owner": "markhazleton",
      "name": "FastEndpointApi"
    },
    "category": "readme",
    "pushed_at": "2025-11-16T23:08:34+00:00",
    "ttl_enforced": false
  },
  "category": "readme",
  "owner": "markhazleton",
  "repo": "FastEndpointApi",
  "week": "2025W46"
}