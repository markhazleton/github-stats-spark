{
  "timestamp": "2026-01-08T17:50:15.747651+00:00",
  "value": "# \ud83d\ude80 TaskListProcessor\n\n[![.NET](https://img.shields.io/badge/.NET-10.0-512BD4?style=flat-square&logo=dotnet)](https://dotnet.microsoft.com/)\n[![License](https://img.shields.io/badge/License-MIT-green.svg?style=flat-square)](LICENSE)\n[![Build Status](https://img.shields.io/badge/Build-Passing-brightgreen?style=flat-square)](https://github.com/markhazleton/TaskListProcessor)\n[![NuGet](https://img.shields.io/badge/NuGet-Coming%20Soon-orange?style=flat-square)](https://www.nuget.org/packages/TaskListProcessor)\n\n> **A modern, enterprise-grade .NET 10.0 library for orchestrating asynchronous operations with comprehensive telemetry, circuit breakers, dependency injection, and advanced scheduling capabilities.**\n\n---\n\n## \ud83d\udcd1 Table of Contents\n\n- [\ud83d\ude80 TaskListProcessor](#-tasklistprocessor)\n  - [\ud83d\udcd1 Table of Contents](#-table-of-contents)\n  - [\u2728 Overview](#-overview)\n  - [\ud83c\udfaf Why TaskListProcessor?](#-why-tasklistprocessor)\n  - [\ud83d\udd25 Key Features](#-key-features)\n  - [\ud83c\udfd7\ufe0f Architecture](#\ufe0f-architecture)\n  - [\u26a1 Quick Start](#-quick-start)\n  - [\ud83d\udcd6 Comprehensive Examples](#-comprehensive-examples)\n  - [\ud83d\udd27 Advanced Usage](#-advanced-usage)\n  - [\ud83d\udcca Performance & Telemetry](#-performance--telemetry)\n  - [\ud83d\udee0\ufe0f API Reference](#\ufe0f-api-reference)\n  - [\ud83e\uddea Testing](#-testing)\n  - [\ud83d\udd04 Migration Guide](#-migration-guide)\n  - [\ud83c\udfd7\ufe0f Project Structure](#\ufe0f-project-structure)\n  - [\ud83e\udd1d Contributing](#-contributing)\n  - [\ud83d\udcdc License](#-license)\n  - [\ud83d\udd17 Resources](#-resources)\n\n---\n\n## \u2728 Overview\n\nTaskListProcessor is a production-ready .NET 10.0 library designed to solve complex asynchronous orchestration challenges in modern applications. Built with enterprise-grade patterns including dependency injection, circuit breakers, task scheduling, and comprehensive telemetry, it provides a robust foundation for high-throughput, fault-tolerant systems.\n\n### \ud83c\udfaf Why TaskListProcessor?\n\n**The Problem:** Modern applications require sophisticated coordination of multiple async operations\u2014API calls, database queries, file I/O, microservice interactions\u2014while maintaining resilience, observability, and performance under varying loads.\n\n**The Solution:** TaskListProcessor provides a battle-tested, enterprise-ready framework with:\n\n- \ud83d\udee1\ufe0f **Fault Isolation**: Circuit breakers and individual task failure isolation\n- \ud83d\udcca **Enterprise Observability**: OpenTelemetry integration with rich metrics and tracing\n- \u26a1 **Advanced Scheduling**: Priority-based, dependency-aware task execution\n- \ud83c\udfaf **Type Safety**: Strongly-typed results with comprehensive error categorization\n- \ud83d\udd27 **Dependency Injection**: Native .NET DI integration with decorator pattern support\n- \ud83c\udfd7\ufe0f **Interface Segregation**: Clean, focused interfaces following SOLID principles\n\n## \ud83d\udd25 Key Features\n\n### Core Processing Capabilities\n\n- **\ud83d\ude80 Concurrent Execution**: Parallel task processing with configurable concurrency limits and load balancing\n- **\ud83d\udee1\ufe0f Circuit Breaker Pattern**: Automatic failure detection and cascading failure prevention\n- **\ud83d\udcca Rich Telemetry**: Comprehensive timing, success rates, error tracking, and OpenTelemetry integration\n- **\ud83c\udfaf Type Safety**: Strongly-typed results with full IntelliSense support and error categorization\n- **\u23f1\ufe0f Timeout & Cancellation**: Built-in support for graceful shutdown and per-task timeouts\n- **\ud83d\udd04 Task Dependencies**: Dependency resolution with topological sorting and execution ordering\n\n### Enterprise Architecture Features\n\n- **\ud83c\udfd7\ufe0f Dependency Injection**: Native .NET DI integration with fluent configuration API\n- **\ud83c\udfa8 Interface Segregation**: Clean, focused interfaces following SOLID principles\n- **\ufffd Decorator Pattern**: Pluggable cross-cutting concerns (logging, metrics, circuit breakers)\n- **\ud83d\udcc8 Advanced Scheduling**: Priority-based, FIFO, LIFO, and custom scheduling strategies\n- **\ud83e\uddf5 Thread Safety**: Lock-free concurrent collections and thread-safe operations\n- **\ud83d\udcbe Memory Optimization**: Object pooling and efficient memory management\n\n### Developer Experience\n\n- **\ufffd Structured Logging**: Integration with Microsoft.Extensions.Logging and Serilog\n- **\ud83d\udd0d Health Checks**: Built-in health monitoring and diagnostic capabilities\n- **\ufffd Streaming Results**: Async enumerable support for real-time result processing\n- **\ud83e\uddea Testing Support**: Comprehensive test helpers and mock-friendly interfaces\n- **\ud83d\udcd6 Rich Documentation**: Extensive XML documentation and practical examples\n\n---\n\n## \ud83d\udea6 Getting Started\n\n### \ud83c\udf93 Choose Your Learning Path\n\n<table>\n<tr>\n<td width=\"33%\" valign=\"top\">\n\n#### \ud83d\udfe2 **New to TaskListProcessor?**\n\nStart here for a guided introduction:\n\n1. **[5-Minute Quick Start](docs/getting-started/01-quick-start-5-minutes.md)** \u26a1\n   Get your first processor running in 5 minutes\n\n2. **[Fundamentals](docs/getting-started/02-fundamentals.md)** \ud83d\udcda\n   Understand core concepts and architecture\n\n3. **[Your First Real Processor](docs/getting-started/03-your-first-processor.md)** \ud83c\udf93\n   Build a production-ready Travel Dashboard\n\n4. **[Common Pitfalls](docs/getting-started/04-common-pitfalls.md)** \u26a0\ufe0f\n   Avoid the 10 most common mistakes\n\n**Time to productivity**: ~70 minutes\n\n</td>\n<td width=\"33%\" valign=\"top\">\n\n#### \ud83d\udfe1 **Ready for More?**\n\nExplore intermediate features:\n\n1. **[Dependency Injection](docs/tutorials/intermediate/01-dependency-injection.md)** \ud83d\udd27\n   Integrate with ASP.NET Core\n\n2. **[Circuit Breaker Pattern](docs/tutorials/intermediate/02-circuit-breaker-pattern.md)** \ud83d\udee1\ufe0f\n   Build resilient applications\n\n3. **[Advanced Scheduling](docs/tutorials/intermediate/03-advanced-scheduling.md)** \ud83d\udcc5\n   Priority and dependency-based execution\n\n4. **[Task Dependencies](docs/tutorials/intermediate/04-task-dependencies.md)** \ud83d\udd17\n   Coordinate complex workflows\n\n5. **[Streaming Results](docs/tutorials/intermediate/05-streaming-results.md)** \ud83d\udce1\n   Process results in real-time\n\n</td>\n<td width=\"33%\" valign=\"top\">\n\n#### \ud83d\udd34 **Production Ready?**\n\nAdvanced topics and optimization:\n\n1. **[Memory Optimization](docs/tutorials/advanced/01-memory-optimization.md)** \ud83d\udcbe\n   Handle large-scale processing\n\n2. **[Load Balancing](docs/tutorials/advanced/02-load-balancing.md)** \u2696\ufe0f\n   Distribute work efficiently\n\n3. **[OpenTelemetry Integration](docs/tutorials/advanced/03-opentelemetry-integration.md)** \ud83d\udcca\n   Enterprise observability\n\n4. **[Performance Tuning](docs/tutorials/advanced/05-performance-tuning.md)** \ud83d\ude80\n   Optimize for production\n\n5. **[Production Patterns](docs/tutorials/advanced/06-production-patterns.md)** \ud83c\udfed\n   Battle-tested strategies\n\n</td>\n</tr>\n</table>\n\n### \ud83d\udcd6 Complete Documentation\n\n- **[Getting Started Hub](docs/getting-started/00-README.md)** - All learning paths and resources\n- **[Interactive Examples](examples/TaskListProcessor.Web)** - Try it in your browser (run the web demo)\n- **[Architecture Deep Dive](docs/architecture/design-principles.md)** - SOLID principles and design patterns\n- **[Performance Guide](docs/architecture/performance-considerations.md)** - Benchmarks and optimization\n- **[FAQ](docs/troubleshooting/faq.md)** - 40+ common questions answered\n- **[API Reference](docs/api-reference/)** - Complete API documentation\n\n### \ud83c\udd98 Need Help?\n\n- **Quick answers**: [FAQ](docs/troubleshooting/faq.md)\n- **Common issues**: [Troubleshooting Guide](docs/troubleshooting/common-issues.md)\n- **Ask questions**: [GitHub Discussions](https://github.com/markhazleton/TaskListProcessor/discussions)\n- **Report bugs**: [GitHub Issues](https://github.com/markhazleton/TaskListProcessor/issues)\n\n---\n\n## \ud83c\udfd7\ufe0f Architecture\n\nTaskListProcessor implements a modern, enterprise-ready architecture with clear separation of concerns:\n\n```ascii\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Dependency Injection Layer                  \u2502\n\u2502        services.AddTaskListProcessor().WithAllDecorators()     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n                                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      Decorator Chain                            \u2502\n\u2502  LoggingDecorator \u2192 MetricsDecorator \u2192 CircuitBreakerDecorator  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n                                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Interface Segregation Layer                 \u2502\n\u2502  ITaskProcessor \u2502 ITaskBatchProcessor \u2502 ITaskStreamProcessor   \u2502\n\u2502              ITaskTelemetryProvider                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n                                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Core Processing Engine                       \u2502\n\u2502            TaskListProcessorEnhanced (Backward Compatible)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502                 \u2502                 \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 TaskDefinition   \u2502 \u2502TaskTelemetry\u2502 \u2502TaskProgress  \u2502\n    \u2502 + Dependencies   \u2502 \u2502 + Metrics   \u2502 \u2502 + Reporting  \u2502\n    \u2502 + Priority       \u2502 \u2502 + Tracing   \u2502 \u2502 + Streaming  \u2502\n    \u2502 + Scheduling     \u2502 \u2502 + Health    \u2502 \u2502 + Estimates  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### Core Components\n\n- **Interface Layer**: Clean, focused interfaces for different processing scenarios\n- **Decorator Layer**: Cross-cutting concerns (logging, metrics, circuit breakers)\n- **Processing Engine**: Thread-safe orchestration with advanced scheduling\n- **Telemetry System**: Comprehensive observability and health monitoring\n- **Dependency Resolution**: Topological sorting and execution ordering\n- **Circuit Breaker**: Cascading failure prevention and automatic recovery\n\n## \u26a1 Quick Start\n\n### Installation\n\n```bash\n# Clone the repository\ngit clone https://github.com/markhazleton/TaskListProcessor.git\ncd TaskListProcessor\n\n# Build the solution\ndotnet build\n\n# Run the demo\ndotnet run --project examples/TaskListProcessor.Console\n```\n\n### Basic Usage (Direct Instantiation)\n\n```csharp\nusing TaskListProcessing.Core;\nusing Microsoft.Extensions.Logging;\n\n// Set up logging (optional but recommended)\nusing var loggerFactory = LoggerFactory.Create(builder => builder.AddConsole());\nvar logger = loggerFactory.CreateLogger<Program>();\n\n// Create the processor\nusing var processor = new TaskListProcessorEnhanced(\"My Tasks\", logger);\n\n// Define your tasks using the factory pattern\nvar taskFactories = new Dictionary<string, Func<CancellationToken, Task<object?>>>\n{\n    [\"Weather Data\"] = async ct => await GetWeatherAsync(\"London\"),\n    [\"Stock Prices\"] = async ct => await GetStockPricesAsync(\"MSFT\"),\n    [\"User Data\"] = async ct => await GetUserDataAsync(userId)\n};\n\n// Execute all tasks concurrently\nawait processor.ProcessTasksAsync(taskFactories, cancellationToken);\n\n// Access results and telemetry\nforeach (var result in processor.TaskResults)\n{\n    Console.WriteLine($\"{result.Name}: {(result.IsSuccessful ? \"\u2705\" : \"\u274c\")}\");\n}\n```\n\n### Dependency Injection Usage (Recommended)\n\n```csharp\nusing TaskListProcessing.Extensions;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\n// Program.cs\nvar builder = Host.CreateApplicationBuilder(args);\n\n// Configure TaskListProcessor with decorators\nbuilder.Services.AddTaskListProcessor(options =>\n{\n    options.MaxConcurrentTasks = 10;\n    options.EnableDetailedTelemetry = true;\n    options.CircuitBreakerOptions = new() { FailureThreshold = 3 };\n})\n.WithLogging()\n.WithMetrics()\n.WithCircuitBreaker();\n\nvar host = builder.Build();\n\n// Usage in your services\npublic class MyService\n{\n    private readonly ITaskBatchProcessor _processor;\n    \n    public MyService(ITaskBatchProcessor processor)\n    {\n        _processor = processor;\n    }\n    \n    public async Task ProcessDataAsync()\n    {\n        var tasks = new Dictionary<string, Func<CancellationToken, Task<object?>>>\n        {\n            [\"API Call\"] = async ct => await CallApiAsync(ct),\n            [\"DB Query\"] = async ct => await QueryDatabaseAsync(ct)\n        };\n        \n        await _processor.ProcessTasksAsync(tasks);\n    }\n}\n```\n\n## \ud83d\udcd6 Comprehensive Examples\n\n### Travel Dashboard (Real-world Scenario)\n\nThis example demonstrates fetching weather and activities data for multiple cities:\n\n```csharp\nusing var processor = new TaskListProcessorEnhanced(\"Travel Dashboard\", logger);\nusing var cts = new CancellationTokenSource(TimeSpan.FromMinutes(2));\n\nvar cities = new[] { \"London\", \"Paris\", \"Tokyo\", \"New York\" };\nvar taskFactories = new Dictionary<string, Func<CancellationToken, Task<object?>>>();\n\n// Create tasks for each city\nforeach (var city in cities)\n{\n    taskFactories[$\"{city} Weather\"] = ct => weatherService.GetWeatherAsync(city, ct);\n    taskFactories[$\"{city} Activities\"] = ct => activitiesService.GetActivitiesAsync(city, ct);\n}\n\n// Execute and handle results\ntry \n{\n    await processor.ProcessTasksAsync(taskFactories, cts.Token);\n    \n    // Group results by city\n    var cityData = processor.TaskResults\n        .GroupBy(r => r.Name.Split(' ')[0])\n        .ToDictionary(g => g.Key, g => g.ToList());\n    \n    // Display results with rich formatting\n    foreach (var (city, results) in cityData)\n    {\n        Console.WriteLine($\"\\n\ud83c\udf0d {city}:\");\n        foreach (var result in results)\n        {\n            var status = result.IsSuccessful ? \"\u2705\" : \"\u274c\";\n            Console.WriteLine($\"  {status} {result.Name.Split(' ')[1]}\");\n        }\n    }\n}\ncatch (OperationCanceledException)\n{\n    logger.LogWarning(\"Operation timed out after 2 minutes\");\n}\n```\n\n### Individual Task Execution\n\nFor scenarios requiring fine-grained control:\n\n```csharp\n// Execute a single task with full telemetry\nvar result = await processor.ExecuteTaskAsync(\n    \"Critical API Call\", \n    httpClient.GetStringAsync(\"https://api.example.com/data\"),\n    cancellationToken);\n\nif (result.IsSuccessful)\n{\n    var data = result.Data;\n    logger.LogInformation(\"Received {DataLength} characters\", data?.Length ?? 0);\n}\nelse\n{\n    logger.LogError(\"API call failed: {Error}\", result.ErrorMessage);\n}\n```\n\n## \ud83d\udd27 Advanced Usage\n\n### Task Dependencies & Scheduling\n\n```csharp\nusing TaskListProcessing.Models;\nusing TaskListProcessing.Scheduling;\n\n// Configure with dependency resolution\nvar options = new TaskListProcessorOptions\n{\n    DependencyResolver = new TopologicalTaskDependencyResolver(),\n    SchedulingStrategy = TaskSchedulingStrategy.Priority,\n    MaxConcurrentTasks = Environment.ProcessorCount * 2\n};\n\nusing var processor = new TaskListProcessorEnhanced(\"Advanced Tasks\", logger, options);\n\n// Define tasks with dependencies and priorities\nvar taskDefinitions = new[]\n{\n    new TaskDefinition\n    {\n        Name = \"Initialize\",\n        Factory = async ct => await InitializeAsync(ct),\n        Priority = TaskPriority.High\n    },\n    new TaskDefinition\n    {\n        Name = \"Process Data\",\n        Factory = async ct => await ProcessDataAsync(ct),\n        Dependencies = new[] { \"Initialize\" },\n        Priority = TaskPriority.Medium\n    },\n    new TaskDefinition\n    {\n        Name = \"Generate Report\",\n        Factory = async ct => await GenerateReportAsync(ct),\n        Dependencies = new[] { \"Process Data\" },\n        Priority = TaskPriority.Low\n    }\n};\n\nawait processor.ProcessTaskDefinitionsAsync(taskDefinitions);\n```\n\n### Circuit Breaker Configuration\n\n```csharp\nvar options = new TaskListProcessorOptions\n{\n    CircuitBreakerOptions = new CircuitBreakerOptions\n    {\n        FailureThreshold = 5,\n        RecoveryTimeout = TimeSpan.FromMinutes(2),\n        MinimumThroughput = 10\n    }\n};\n\nusing var processor = new TaskListProcessorEnhanced(\"Resilient Tasks\", logger, options);\n\n// Tasks will automatically trigger circuit breaker on repeated failures\nvar taskFactories = new Dictionary<string, Func<CancellationToken, Task<object?>>>\n{\n    [\"Resilient API\"] = async ct => await CallExternalApiAsync(ct),\n    [\"Fallback Service\"] = async ct => await CallFallbackServiceAsync(ct)\n};\n\nawait processor.ProcessTasksAsync(taskFactories);\n\n// Check circuit breaker status\nvar cbStats = processor.CircuitBreakerStats;\nif (cbStats?.State == CircuitBreakerState.Open)\n{\n    Console.WriteLine($\"Circuit breaker opened at {cbStats.OpenedAt}\");\n}\n```\n\n### Streaming Results\n\n```csharp\nusing TaskListProcessing.Interfaces;\n\n// Inject the stream processor\npublic class StreamingService\n{\n    private readonly ITaskStreamProcessor _streamProcessor;\n    \n    public StreamingService(ITaskStreamProcessor streamProcessor)\n    {\n        _streamProcessor = streamProcessor;\n    }\n    \n    public async Task ProcessWithStreamingAsync()\n    {\n        var tasks = CreateLongRunningTasks();\n        \n        // Process results as they complete\n        await foreach (var result in _streamProcessor.ProcessTasksStreamAsync(tasks))\n        {\n            Console.WriteLine($\"Completed: {result.Name} - {result.IsSuccessful}\");\n            \n            // Process result immediately without waiting for all tasks\n            await HandleResultAsync(result);\n        }\n    }\n}\n```\n\n### Health Monitoring\n\n```csharp\nvar options = new TaskListProcessorOptions\n{\n    HealthCheckOptions = new HealthCheckOptions\n    {\n        MinSuccessRate = 0.8, // 80% success rate threshold\n        MaxAverageExecutionTime = TimeSpan.FromSeconds(5),\n        IncludeCircuitBreakerState = true\n    }\n};\n\nusing var processor = new TaskListProcessorEnhanced(\"Health Monitored\", logger, options);\n\n// After processing tasks\nvar healthResult = processor.PerformHealthCheck();\nif (!healthResult.IsHealthy)\n{\n    Console.WriteLine($\"Health check failed: {healthResult.Message}\");\n}\n\n// Get detailed telemetry\nvar telemetrySummary = processor.GetTelemetrySummary();\nConsole.WriteLine($\"Success rate: {telemetrySummary.SuccessRate:F1}%\");\nConsole.WriteLine($\"Average execution time: {telemetrySummary.AverageExecutionTime:F0}ms\");\n```\n\n## \ud83d\udcca Performance & Telemetry\n\nTaskListProcessor provides comprehensive telemetry out of the box:\n\n### Built-in Metrics\n\n```csharp\n// Access telemetry after execution\nvar telemetry = processor.Telemetry;\nvar successRate = telemetry.Count(t => t.IsSuccessful) / (double)telemetry.Count * 100;\nvar averageTime = telemetry.Average(t => t.DurationMs);\nvar throughput = telemetry.Count / telemetry.Max(t => t.DurationMs) * 1000;\n\nConsole.WriteLine($\"\ud83d\udcca Success Rate: {successRate:F1}%\");\nConsole.WriteLine($\"\u23f1\ufe0f Average Time: {averageTime:F0}ms\");\nConsole.WriteLine($\"\ud83d\ude80 Throughput: {throughput:F1} tasks/second\");\n```\n\n### Sample Telemetry Output\n\n```text\n=== \ud83d\udcca TELEMETRY SUMMARY ===\n\ud83d\udcc8 Total Tasks: 16\n\u2705 Successful: 13 (81.2%)\n\u274c Failed: 3\n\u23f1\ufe0f Average Time: 1,305ms\n\ud83c\udfc3 Fastest: 157ms | \ud83d\udc0c Slowest: 2,841ms\n\u23f0 Total Execution Time: 20,884ms\n\n=== \ud83d\udccb DETAILED TELEMETRY ===\n\u2705 Successful Tasks (sorted by execution time):\n  \ud83d\ude80 London Things To Do: 157ms\n  \ud83d\ude80 Dallas Things To Do: 339ms\n  \u26a1 Chicago Things To Do: 557ms\n  \ud83c\udfc3 London Weather: 1,242ms\n  ...\n\n\u274c Failed Tasks:\n  \ud83d\udca5 Sydney Things To Do: ArgumentException after 807ms\n  \ud83d\udca5 Tokyo Things To Do: ArgumentException after 424ms\n```\n\n## \ud83d\udee0\ufe0f API Reference\n\n### Core Interfaces\n\n| Interface | Description | Key Methods |\n|-----------|-------------|-------------|\n| `ITaskProcessor` | Single task execution | `ExecuteTaskAsync<T>()` |\n| `ITaskBatchProcessor` | Batch processing | `ProcessTasksAsync()`, `ProcessTaskDefinitionsAsync()` |\n| `ITaskStreamProcessor` | Streaming results | `ProcessTasksStreamAsync()` |\n| `ITaskTelemetryProvider` | Telemetry & health | `GetTelemetrySummary()`, `PerformHealthCheck()` |\n\n### TaskListProcessorEnhanced (Backward Compatible)\n\n| Method | Description | Returns |\n|--------|-------------|---------|\n| `ProcessTasksAsync(taskFactories, progress, ct)` | Execute multiple tasks concurrently | `Task` |\n| `ProcessTaskDefinitionsAsync(definitions, progress, ct)` | Execute tasks with dependencies | `Task` |\n| `ExecuteTaskAsync<T>(name, task, ct)` | Execute single task with telemetry | `Task<EnhancedTaskResult<T>>` |\n| `ProcessTasksStreamAsync(taskFactories, ct)` | Stream results as they complete | `IAsyncEnumerable<EnhancedTaskResult<object>>` |\n| `GetTelemetrySummary()` | Get comprehensive telemetry | `TelemetrySummary` |\n| `PerformHealthCheck()` | Check processor health | `HealthCheckResult` |\n\n### Configuration Options\n\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| `MaxConcurrentTasks` | `int` | `Environment.ProcessorCount * 2` | Maximum concurrent tasks |\n| `DefaultTaskTimeout` | `TimeSpan` | `5 minutes` | Default task timeout |\n| `EnableDetailedTelemetry` | `bool` | `true` | Enable comprehensive telemetry |\n| `CircuitBreakerOptions` | `CircuitBreakerOptions?` | `null` | Circuit breaker configuration |\n| `SchedulingStrategy` | `TaskSchedulingStrategy` | `FirstInFirstOut` | Task scheduling strategy |\n| `DependencyResolver` | `ITaskDependencyResolver?` | `null` | Dependency resolution |\n\n### Data Models\n\n| Model | Description | Key Properties |\n|-------|-------------|----------------|\n| `EnhancedTaskResult<T>` | Task execution result | `Data`, `IsSuccessful`, `ErrorMessage`, `ErrorCategory` |\n| `TaskTelemetry` | Telemetry data | `TaskName`, `ElapsedMilliseconds`, `IsSuccessful` |\n| `TaskProgress` | Progress information | `CompletedTasks`, `TotalTasks`, `CurrentTask` |\n| `TaskDefinition` | Task with metadata | `Name`, `Factory`, `Dependencies`, `Priority` |\n| `CircuitBreakerStats` | Circuit breaker state | `State`, `FailureCount`, `OpenedAt` |\n| `TelemetrySummary` | Aggregated telemetry | `SuccessRate`, `AverageExecutionTime`, `TotalTasks` |\n\n## \ud83e\uddea Testing\n\nRun the comprehensive test suite:\n\n```bash\n# Run all tests\ndotnet test\n\n# Run with coverage\ndotnet test --collect:\"XPlat Code Coverage\"\n\n# Run specific test category\ndotnet test --filter Category=Integration\n```\n\n### Test Coverage\n\n- \u2705 **Unit Tests**: Core functionality and edge cases\n- \u2705 **Integration Tests**: End-to-end scenarios  \n- \u2705 **Performance Tests**: Throughput and latency validation\n- \u2705 **Stress Tests**: High-concurrency scenarios\n\n## \ud83c\udfd7\ufe0f Project Structure\n\nTaskListProcessor follows a clean architecture with clear separation of concerns:\n\n```text\nTaskListProcessor/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 TaskListProcessing/                    # Core library\n\u2502   \u2502   \u251c\u2500\u2500 Core/                             # Core implementations\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TaskListProcessorEnhanced.cs  # Main orchestrator\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TaskProcessor.cs              # Single task execution\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TaskBatchProcessor.cs         # Batch processing\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TaskStreamProcessor.cs        # Streaming results\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 TaskTelemetryProvider.cs      # Telemetry collection\n\u2502   \u2502   \u251c\u2500\u2500 Interfaces/                       # Interface segregation\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ITaskProcessor.cs             # Single task interface\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ITaskBatchProcessor.cs        # Batch processing interface\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ITaskStreamProcessor.cs       # Streaming interface\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ITaskTelemetryProvider.cs     # Telemetry interface\n\u2502   \u2502   \u251c\u2500\u2500 Extensions/                       # DI integration\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ServiceCollectionExtensions.cs\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 TaskProcessorBuilder.cs\n\u2502   \u2502   \u251c\u2500\u2500 Models/                           # Data models\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 EnhancedTaskResult.cs\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TaskDefinition.cs\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TaskProgress.cs\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 HealthCheckResult.cs\n\u2502   \u2502   \u251c\u2500\u2500 Scheduling/                       # Task scheduling\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TaskSchedulingStrategy.cs\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 AdvancedTaskScheduler.cs\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 TopologicalTaskDependencyResolver.cs\n\u2502   \u2502   \u251c\u2500\u2500 CircuitBreaker/                   # Circuit breaker pattern\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 CircuitBreaker.cs\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 CircuitBreakerOptions.cs\n\u2502   \u2502   \u251c\u2500\u2500 LoadBalancing/                    # Load balancing\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoadBalancingStrategy.cs\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 LoadBalancingTaskDistributor.cs\n\u2502   \u2502   \u251c\u2500\u2500 Telemetry/                        # Telemetry & metrics\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TaskTelemetry.cs\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TelemetrySummary.cs\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SchedulerStats.cs\n\u2502   \u2502   \u251c\u2500\u2500 Options/                          # Configuration\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TaskListProcessorOptions.cs\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 CircuitBreakerOptions.cs\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 HealthCheckOptions.cs\n\u2502   \u2502   \u251c\u2500\u2500 Decorators/                       # Cross-cutting concerns\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoggingTaskProcessorDecorator.cs\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 MetricsTaskProcessorDecorator.cs\n\u2502   \u2502   \u251c\u2500\u2500 Testing/                          # Test utilities\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 TaskListProcessorTestHelpers.cs\n\u2502   \u2502   \u2514\u2500\u2500 Utilities/                        # Helper classes\n\u2502   \u251c\u2500\u2500 CityWeatherService/                   # Example service\n\u2502   \u2502   \u251c\u2500\u2500 WeatherService.cs\n\u2502   \u2502   \u2514\u2500\u2500 CityWeatherService.csproj\n\u2502   \u2514\u2500\u2500 CityThingsToDo/                       # Example service\n\u2502       \u251c\u2500\u2500 CityThingsToDoService.cs\n\u2502       \u2514\u2500\u2500 CityThingsToDo.csproj\n\u251c\u2500\u2500 examples/\n\u2502   \u2514\u2500\u2500 TaskListProcessor.Console/            # Demo application\n\u2502       \u251c\u2500\u2500 Program.cs\n\u2502       \u2514\u2500\u2500 Utilities/\n\u2502           \u251c\u2500\u2500 AppConfiguration.cs\n\u2502           \u251c\u2500\u2500 OutputFormatter.cs\n\u2502           \u251c\u2500\u2500 ResultsDisplay.cs\n\u2502           \u2514\u2500\u2500 TelemetryDisplay.cs\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 TaskListProcessing.Tests/             # Core library tests\n\u2502   \u2502   \u251c\u2500\u2500 InterfaceSegregationTests.cs\n\u2502   \u2502   \u2514\u2500\u2500 TaskListProcessing.Tests.csproj\n\u2502   \u251c\u2500\u2500 CityWeatherService.Tests/             # Service tests\n\u2502   \u2502   \u251c\u2500\u2500 WeatherServiceTests.cs\n\u2502   \u2502   \u2514\u2500\u2500 CityWeatherService.Tests.csproj\n\u2502   \u2514\u2500\u2500 CityThingsToDo.Tests/                 # Service tests\n\u2502       \u251c\u2500\u2500 CityThingsToDoServiceTests.cs\n\u2502       \u2514\u2500\u2500 CityThingsToDo.Tests.csproj\n\u251c\u2500\u2500 docs/                                     # Documentation\n\u2502   \u251c\u2500\u2500 PHASE1_README.md                      # Phase 1 features\n\u2502   \u251c\u2500\u2500 MIGRATION_GUIDE.md                    # Migration guide\n\u2502   \u2514\u2500\u2500 CLEANUP_SUMMARY.md                    # Cleanup notes\n\u2514\u2500\u2500 README.md                                 # This file\n```\n\n### Key Architecture Principles\n\n- **Interface Segregation**: Clean, focused interfaces for different scenarios\n- **Dependency Injection**: Native .NET DI with fluent configuration\n- **Single Responsibility**: Each component has a clear, focused purpose\n- **Extensibility**: Decorator pattern for cross-cutting concerns\n- **Testability**: Mockable interfaces and comprehensive test coverage\n\n## \ud83d\udd04 Migration Guide\n\n### From Legacy Processors to Modern Interfaces\n\n**Recommended Migration Path:**\n\n1. **Migrate to Dependency Injection** (Recommended)\n\n```csharp\n// Old approach\nvar processor = new TaskListProcessorEnhanced(\"Tasks\", logger);\n\n// New approach\nservices.AddTaskListProcessor(options =>\n{\n    options.MaxConcurrentTasks = 10;\n    options.EnableDetailedTelemetry = true;\n})\n.WithLogging()\n.WithMetrics();\n\n// In your service\npublic class MyService\n{\n    private readonly ITaskBatchProcessor _processor;\n    public MyService(ITaskBatchProcessor processor) => _processor = processor;\n}\n```\n\n2. **Direct Interface Usage** (Alternative)\n\n```csharp\n// Single task processing\nvar taskProcessor = new TaskProcessor(\"SingleTasks\", logger);\nvar result = await taskProcessor.ExecuteTaskAsync(\"task\", someTask);\n\n// Batch processing\nvar batchProcessor = new TaskBatchProcessor(\"BatchTasks\", logger);\nawait batchProcessor.ProcessTasksAsync(taskFactories);\n\n// Streaming results\nvar streamProcessor = new TaskStreamProcessor(\"StreamTasks\", logger);\nawait foreach (var result in streamProcessor.ProcessTasksStreamAsync(tasks))\n{\n    // Process results as they complete\n}\n```\n\n3. **Backward Compatibility** (For existing code)\n\n```csharp\n// TaskListProcessorEnhanced still works with all existing features\nusing var processor = new TaskListProcessorEnhanced(\"Legacy\", logger);\nawait processor.ProcessTasksAsync(taskFactories);\n```\n\n### New Features in Current Version\n\n- **Interface Segregation**: Clean, focused interfaces for different scenarios\n- **Dependency Injection**: Native .NET DI integration with fluent configuration\n- **Task Dependencies**: Topological sorting and dependency resolution\n- **Circuit Breaker**: Automatic failure detection and recovery\n- **Advanced Scheduling**: Priority-based, dependency-aware task execution\n- **Streaming Results**: Real-time result processing via async enumerables\n- **Enhanced Telemetry**: OpenTelemetry integration and health monitoring\n- **Memory Optimization**: Object pooling and efficient resource management\n\n### Breaking Changes\n\n1. **Namespace Changes**: Main classes moved to `TaskListProcessing.Core`\n2. **Interface Requirements**: New interfaces may require additional dependencies\n3. **Configuration Options**: Enhanced options structure with validation\n4. **Result Types**: Enhanced error categorization and telemetry data\n\n## \ud83e\udd1d Contributing\n\nWe welcome contributions! Here's how to get started:\n\n### Development Setup\n\n```bash\n# Clone and setup\ngit clone https://github.com/markhazleton/TaskListProcessor.git\ncd TaskListProcessor\n\n# Restore dependencies\ndotnet restore\n\n# Build solution  \ndotnet build\n\n# Run tests\ndotnet test\n```\n\n### Contribution Guidelines\n\n1. **\ud83c\udf74 Fork** the repository\n2. **\ud83c\udf3f Create** a feature branch (`git checkout -b feature/amazing-feature`)\n3. **\u2728 Make** your changes with tests\n4. **\u2705 Verify** all tests pass (`dotnet test`)\n5. **\ud83d\udcdd Commit** your changes (`git commit -m 'Add amazing feature'`)\n6. **\ud83d\ude80 Push** to the branch (`git push origin feature/amazing-feature`)\n7. **\ud83c\udfaf Open** a Pull Request\n\n### Code Standards\n\n- Follow [C# Coding Conventions](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions)\n- Add XML documentation for public APIs\n- Include unit tests for new features\n- Maintain backward compatibility when possible\n\n## \ud83d\udcdc License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n\n```text\nMIT License\n\nCopyright (c) 2024 Mark Hazleton\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n```\n\n## \ud83d\udd17 Resources\n\n### \ud83d\udcda Documentation & Articles\n\n- [\ud83d\udcd6 Phase 1 Features Guide](docs/PHASE1_README.md) - Interface segregation and dependency injection\n- [\ud83d\udcdd Migration Guide](docs/MIGRATION_GUIDE.md) - Detailed migration instructions\n- [\ud83d\udd04 Cleanup Summary](docs/CLEANUP_SUMMARY.md) - Recent improvements and changes\n- [\ud83c\udf10 Complete Technical Article](https://markhazleton.com/task-list-processor.html) - Deep dive into architecture and patterns\n- [\ufffd Best Practices Guide](https://markhazleton.com/async-best-practices.html) - Async programming patterns\n\n### \ud83c\udfaf Examples & Demos\n\n- [\ud83d\udda5\ufe0f Console Demo](examples/TaskListProcessor.Console/) - Interactive demonstration\n- [\ud83c\udf10 Web Dashboard Example](examples/TaskListProcessor.Web/) - ASP.NET Core integration\n- [\ud83d\udcca Performance Benchmarks](benchmarks/) - Performance analysis and comparisons\n\n### \ud83d\udc65 Community & Support\n\n- [\ud83d\udc1b Report Issues](https://github.com/markhazleton/TaskListProcessor/issues) - Bug reports and feature requests\n- [\ud83d\udcac Discussions](https://github.com/markhazleton/TaskListProcessor/discussions) - Community support and Q&A\n- [\ud83d\udce7 Contact Mark](mailto:mark@markhazleton.com) - Direct contact for enterprise support\n\n### \ud83d\udd17 Mark Hazleton Online\n\n- [\ud83c\udf10 Website](https://markhazleton.com) - Blog and technical articles\n- [\ud83d\udcbc LinkedIn](https://www.linkedin.com/in/markhazleton) - Professional network\n- [\ud83d\udcfa YouTube](https://www.youtube.com/@MarkHazleton) - Technical tutorials and demos\n- [\ud83d\udcf8 Instagram](https://www.instagram.com/markhazleton/) - Behind the scenes content\n\n---\n\n## \ud83d\ude80 Get Started Today\n\nReady to supercharge your async operations? Get started with TaskListProcessor:\n\n```bash\ngit clone https://github.com/markhazleton/TaskListProcessor.git\ncd TaskListProcessor\ndotnet run --project examples/TaskListProcessor.Console\n```\n\n**See it in action with our interactive demo that showcases:**\n\n- \ud83c\udf0d Multi-city travel data aggregation with dependency resolution\n- \u26a1 Concurrent API calls with circuit breaker protection\n- \ud83d\udcca Rich telemetry with OpenTelemetry integration\n- \ud83c\udfaf Type-safe result processing with error categorization\n- \u23f1\ufe0f Advanced scheduling with priority-based execution\n- \ud83d\udd04 Streaming results via async enumerables\n- \ud83c\udfd7\ufe0f Dependency injection with decorator pattern support\n\n*Built with \u2764\ufe0f by [Mark Hazleton](https://markhazleton.com) \u2022 Follow for more .NET content and best practices*\n\n---\n\n## \ud83d\udcc8 Project Stats\n\n![GitHub stars](https://img.shields.io/github/stars/markhazleton/TaskListProcessor?style=social)\n![GitHub forks](https://img.shields.io/github/forks/markhazleton/TaskListProcessor?style=social)\n![GitHub issues](https://img.shields.io/github/issues/markhazleton/TaskListProcessor)\n![GitHub last commit](https://img.shields.io/github/last-commit/markhazleton/TaskListProcessor)\n\n*\u2b50 If this project helped you, please consider giving it a star!*\n",
  "hash": "a114a3101da591a11e235fd3166bc939b5e0c779e3c38abc54210bb388e3aaf8",
  "metadata": {
    "repository": {
      "owner": "markhazleton",
      "name": "TaskListProcessor"
    },
    "category": "readme",
    "pushed_at": "2025-12-08T00:03:40+00:00",
    "ttl_enforced": false
  },
  "category": "readme",
  "owner": "markhazleton",
  "repo": "TaskListProcessor",
  "week": "2025-12-08T00-03-40+00-00"
}