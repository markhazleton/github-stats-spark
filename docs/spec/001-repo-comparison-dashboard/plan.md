# Implementation Plan: Repository Comparison Dashboard

**Branch**: `001-repo-comparison-dashboard` | **Date**: 2026-01-02 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/docs/spec/001-repo-comparison-dashboard/spec.md`

## Summary

Build a world-class interactive repository comparison dashboard using React 18+, Vite 5+, and Recharts, deployed to GitHub Pages. The dashboard provides immersive exploration of repository metrics through sortable tables, interactive visualizations, and side-by-side comparisons. Python backend collects GitHub data and generates JSON files; React frontend consumes this data and renders it with smooth animations and responsive design. Vite build process produces single optimized `site.js` and `site.css` bundles following modern GitHub Pages static site best practices.

## Technical Context

**Language/Version**:
- Backend: Python 3.11+ (existing)
- Frontend: JavaScript ES2020+ via React 18+, Node.js 18+, npm 9+

**Primary Dependencies**:
- Backend: PyGithub 2.1.1+, anthropic 0.40.0+, svgwrite 1.4.3+
- Frontend: React 18+, Vite 5+, Recharts 2.x, CSS Modules (built into Vite)

**Storage**:
- JSON data files in `/docs/data/` directory (generated by Python, consumed by React)
- No database; static file-based data persistence

**Testing**:
- Backend: pytest (existing Python test suite)
- Frontend: Vitest (Vite's test runner) + React Testing Library

**Target Platform**:
- GitHub Pages static hosting from `/docs` directory
- Modern browsers: Chrome, Firefox, Safari, Edge (latest 2 versions)

**Project Type**: Web application (Python backend + React frontend)

**Performance Goals**:
- Initial page load: <5 seconds for 50 repositories
- Bundle sizes: site.js <500KB gzipped, site.css <100KB gzipped
- Lighthouse performance score: 90+
- Sorting/filtering: <1 second for 100 repositories
- Chart rendering: <2 seconds for 100 repositories
- 60 FPS animations and transitions

**Constraints**:
- GitHub Pages static hosting only (no server-side processing at runtime)
- Data updates via GitHub Actions workflow (not real-time)
- GitHub API rate limits: 5000 requests/hour authenticated
- Single-page application architecture (client-side routing)
- Must maintain compatibility with existing Python Stats Spark implementation

**Scale/Scope**:
- Support up to 200 public repositories per user
- Single configured GitHub username per deployment
- Responsive design for desktop and mobile viewports
- Integration with existing SVG visualizations (heatmap, streaks, languages, etc.)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Compliance Assessment

✅ **I. Python-First**: Dashboard extends existing Python modules (`fetcher.py`, `calculator.py`) with new `dashboard_generator.py` for JSON output. Python remains responsible for all GitHub API interactions and business logic.

✅ **II. CLI Interface**: New command `spark dashboard --user <username>` generates dashboard JSON data. Existing CLI structure preserved.

✅ **III. Data Privacy (NON-NEGOTIABLE)**: Frontend only displays public repository data from JSON files generated by Python backend, which already filters private repositories per constitution.

✅ **IV. Testability**: Backend unit tests for JSON generation; frontend tests for React components using Vitest. Maintains >80% coverage requirement.

✅ **V. Observable**: GitHub Actions workflow logs Python data collection, npm install, Vite build, and deployment steps. Build failures visible in Actions logs.

### Performance & Scalability Compliance

✅ **API Rate Limiting**: Existing 6-hour cache TTL applies. No new API calls from frontend (data pre-generated).

✅ **Execution Time**: JSON generation adds <1 minute to existing workflow. Vite build completes in <2 minutes. Total GitHub Actions workflow <5 minutes.

✅ **Accuracy**: Frontend displays data calculated by existing Python modules. No new calculations that could introduce discrepancies.

### Configuration & Customization Compliance

✅ **YAML-Based Configuration**: Dashboard enabled/disabled via `config/spark.yml`. Frontend theme aligns with existing theme system.

⚠️ **New Dependency Justification**: Adding Node.js/npm build toolchain introduces significant new dependencies (React, Vite, Recharts). **Justification**: Required to achieve "world-class visualization" with modern interactive components that exceed capabilities of static SVG generation. Replaces need for custom JavaScript animation/charting code.

### Governance Compliance

✅ **Demo Account**: Continue using `markhazleton` GitHub account for testing and examples.

✅ **Version Management**: Feature represents MINOR version bump (new statistics presentation, no breaking config changes).

## Project Structure

### Documentation (this feature)

```text
docs/spec/001-repo-comparison-dashboard/
├── plan.md              # This file
├── research.md          # Phase 0 output (frontend patterns, build optimization)
├── data-model.md        # Phase 1 output (JSON schema, component state)
├── quickstart.md        # Phase 1 output (local dev setup, build commands)
├── contracts/           # Phase 1 output (JSON API schema, component contracts)
└── tasks.md             # Phase 2 output (NOT created by this command)
```

### Source Code (repository root)

```text
# Backend (existing + new dashboard module)
src/spark/
├── fetcher.py           # Existing: GitHub API interactions
├── calculator.py        # Existing: Statistics calculations
├── visualizer.py        # Existing: SVG generation
├── cache.py             # Existing: API response caching
├── config.py            # Existing: Configuration management
├── dashboard_generator.py  # NEW: JSON data generation for dashboard
└── cli.py               # Modified: Add dashboard command

# Frontend (new React application)
frontend/
├── src/
│   ├── components/      # React components
│   │   ├── Table/       # Repository table with sorting/filtering
│   │   ├── Charts/      # Recharts visualizations
│   │   ├── Comparison/  # Side-by-side comparison view
│   │   ├── Detail/      # Repository detail drill-down
│   │   └── Layout/      # App shell, navigation
│   ├── services/        # Data fetching, state management
│   ├── styles/          # CSS Modules
│   ├── hooks/           # Custom React hooks
│   ├── types/           # TypeScript types (if using TS)
│   ├── utils/           # Helper functions
│   ├── App.jsx          # Root component
│   └── main.jsx         # Entry point
├── public/              # Static assets
├── index.html           # HTML template
├── vite.config.js       # Vite build configuration
├── package.json         # npm dependencies
└── .gitignore           # Ignore node_modules/

# Tests
tests/
├── backend/             # Existing Python tests
│   └── test_dashboard_generator.py  # NEW: Dashboard JSON tests
└── frontend/            # NEW: Frontend tests
    ├── components/      # Component tests
    ├── services/        # Service tests
    └── integration/     # End-to-end tests

# Build output (Git Pages deployment)
docs/
├── index.html           # Generated by Vite
├── assets/
│   ├── site-[hash].js   # Generated optimized JS bundle
│   └── site-[hash].css  # Generated optimized CSS bundle
└── data/
    ├── repositories.json      # Repository metrics
    ├── analysis.json          # AI analysis data
    └── visualizations.json    # SVG visualization references

# GitHub Actions
.github/workflows/
└── stats.yml            # Modified: Add npm install + Vite build steps

# Configuration
config/
└── spark.yml            # Modified: Add dashboard configuration section
```

**Structure Decision**: Hybrid web application architecture. Backend remains Python-first per constitution (I. Python-First). Frontend added as separate `frontend/` directory with React/Vite toolchain. Python generates JSON data during GitHub Actions workflow; React builds to `/docs` for GitHub Pages static hosting. Clean separation of concerns: Python = data collection/processing, React = presentation/interaction.

## Complexity Tracking

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| Node.js/npm/React ecosystem | User requires "world class visualization" with "immersive exploration," smooth animations, drill-down, responsive tooltips, and interactive charts. Static SVG insufficient. | Pure Python + vanilla JS would require writing custom charting library (thousands of LOC), animation framework, and component system. React + Recharts provides battle-tested, accessible, performant solution used by enterprise dashboards. |
| Separate frontend build step | Vite required to combine/optimize client libraries into single site.js and site.css bundles per user requirement. Manual concatenation insufficient. | CDN-based libraries (no bundling) create 10+ HTTP requests degrading performance. Manual script concatenation loses tree-shaking, minification, CSS optimization. Vite Rollup-based build is industry standard for production static sites. |
| CSS Modules approach | Scoped component styling prevents class name conflicts in complex dashboard with tables, charts, modals, tooltips. Global CSS becomes unmaintainable at scale. | Global CSS file would require BEM naming conventions and manual namespace management. Risk of style conflicts between table headers, chart legends, tooltip overlays. CSS Modules provide automatic scoping with zero runtime overhead. |

## Phase 0: Research & Technology Validation

**Objective**: Validate technology choices and establish best practices for React + Vite + GitHub Pages deployment.

### Research Tasks

1. **Vite Configuration for GitHub Pages**
   - Research: Vite base path configuration for `username.github.io/github-stats-spark` URL structure
   - Research: Vite build optimization settings (tree-shaking, code splitting, minification)
   - Research: Output file naming strategy to achieve single `site.js` and `site.css` (vs chunked bundles)

2. **React State Management**
   - Research: Best state management for dashboard (Context API vs Zustand vs Redux)
   - Research: Data fetching patterns for JSON files (fetch on mount, loading states, error handling)
   - Research: Client-side filtering/sorting performance for 200 repositories

3. **Recharts Integration**
   - Research: Recharts chart types mapping (bar, line, scatter for repo metrics)
   - Research: Recharts responsive design patterns for mobile viewports
   - Research: Recharts animation configuration for 60 FPS transitions

4. **CSS Modules Best Practices**
   - Research: CSS Modules file organization (component-scoped vs shared utilities)
   - Research: CSS Modules composition for theme support
   - Research: Bundle size optimization (CSS minification, unused style removal)

5. **GitHub Actions Build Pipeline**
   - Research: Node.js setup action configuration (caching npm dependencies)
   - Research: Vite build output to `/docs` directory strategy
   - Research: Deployment to GitHub Pages from `/docs` folder

6. **Performance Optimization**
   - Research: Code splitting strategies for initial load vs lazy-loaded routes
   - Research: JSON data file splitting (single file vs per-repository files)
   - Research: Image/SVG optimization for existing visualizations embedded in React

7. **Accessibility Compliance**
   - Research: WCAG AA requirements for interactive data tables
   - Research: Keyboard navigation for chart interactions
   - Research: Screen reader announcements for dynamic content updates

**Output**: `research.md` documenting decisions, rationale, and rejected alternatives for each area.

## Phase 1: Design & Contracts

**Prerequisites**: `research.md` complete with all technology decisions validated.

### Deliverables

1. **data-model.md**: JSON schema definitions
   - Repository metrics schema (name, language, commits, sizes, dates)
   - Analysis data schema (AI summaries, quality indicators)
   - Visualization data schema (SVG references, heatmap data)
   - Component state shape (filters, sorts, selections, view mode)

2. **contracts/**: API contracts and component interfaces
   - `contracts/repository-api.json`: JSON schema for `repositories.json`
   - `contracts/analysis-api.json`: JSON schema for `analysis.json`
   - `contracts/component-props.ts`: TypeScript interfaces for React component props
   - `contracts/service-api.ts`: Data service method signatures

3. **quickstart.md**: Developer setup guide
   - Prerequisites (Node.js 18+, npm 9+, Python 3.11+)
   - Local development workflow (`npm run dev` for Vite dev server)
   - Build commands (`npm run build` for production bundle)
   - Testing commands (`npm run test` for Vitest)
   - Deployment process (GitHub Actions workflow overview)

4. **Agent context update**: Update `CLAUDE.md` with new technologies
   - Add: Node.js 18+, npm 9+, React 18+, Vite 5+, Recharts 2.x
   - Add: Frontend test framework (Vitest + React Testing Library)
   - Add: New commands (`npm run dev`, `npm run build`, `npm run test`)

### Design Artifacts to Generate

**Frontend Component Architecture**:
```text
App
├── Layout (header, nav, footer)
└── Router
    ├── DashboardView (default route)
    │   ├── RepositoryTable
    │   ├── ChartSelector
    │   └── ChartViewer (Recharts)
    ├── ComparisonView
    │   ├── RepositoryPicker
    │   └── ComparisonGrid
    └── DetailView (modal/overlay)
        ├── DetailHeader
        ├── DetailMetrics
        ├── DetailCharts
        └── DetailAnalysis
```

**Data Flow Architecture**:
```text
GitHub Actions Workflow
  → Python (spark dashboard)
    → Generate JSON files (/docs/data/*.json)
  → npm install
  → Vite build
    → React app reads JSON
    → Bundle to /docs/assets/
  → Deploy to GitHub Pages
```

**Vite Build Configuration** (key decisions):
- Single bundle output: Disable code splitting for main bundle
- CSS extraction: Single `site.css` file
- Base path: `/github-stats-spark/`
- Output directory: `../docs` (relative to frontend/)

## Phase 2: Task Decomposition

**NOT EXECUTED BY THIS COMMAND**. Run `/speckit.tasks` after Phase 1 complete.

Tasks will include:
1. Backend: Create `dashboard_generator.py` module
2. Backend: Add `spark dashboard` CLI command
3. Backend: Write tests for JSON generation
4. Frontend: Initialize Vite + React project
5. Frontend: Configure Vite for GitHub Pages
6. Frontend: Create repository table component
7. Frontend: Create Recharts visualization components
8. Frontend: Create comparison view
9. Frontend: Create detail view
10. Frontend: Implement data fetching service
11. Frontend: Add CSS Modules styling
12. Frontend: Write component tests
13. GitHub Actions: Update workflow for npm build
14. Documentation: Update README with dashboard instructions

## Constitution Re-Check (Post-Design)

All gates from initial check remain valid. Design phase confirmed:

✅ Python remains single source of truth for data (constitution I)
✅ CLI interface extended with `spark dashboard` command (constitution II)
✅ No private repository data exposure (constitution III)
✅ Test coverage plan for backend JSON generation and frontend components (constitution IV)
✅ Observable GitHub Actions workflow with Vite build logs (constitution V)

**New dependency justification validated**: React + Vite ecosystem necessary to meet "world-class" visualization requirements. No simpler alternative provides required level of interactivity, performance, and maintainability.

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Bundle size exceeds 500KB target | Medium | High | Use Vite's bundle analyzer, implement code splitting for non-critical routes, lazy load Recharts |
| GitHub Pages build timeout (>10min) | Low | High | Optimize npm install caching, verify Vite build time locally, split into separate workflows if needed |
| Recharts performance with 200 repos | Medium | Medium | Implement virtualization for large datasets, limit initial render to 50 repos with pagination |
| CSS Modules class name conflicts | Low | Low | Use BEM-style naming within modules, avoid global styles |
| Breaking existing Python Stats Spark | Low | High | Maintain backward compatibility, add integration tests, use feature flag in config |
| Accessibility compliance failure | Medium | Medium | Implement ARIA labels from design phase, test with screen readers, use semantic HTML |

## Success Criteria (from spec)

- **SC-014**: Production build produces optimized site.js bundle under 500KB (gzipped)
- **SC-015**: Production build produces optimized site.css bundle under 100KB (gzipped)
- **SC-016**: Lighthouse performance score of 90+ for deployed dashboard
- **SC-017**: GitHub Actions build and deployment workflow completes within 5 minutes

All other success criteria (SC-001 through SC-013) inherited from feature specification.

## Next Steps

1. ✅ Complete Phase 0: Generate `research.md` with technology validation
2. ✅ Complete Phase 1: Generate `data-model.md`, `contracts/`, `quickstart.md`
3. ⏭️ Run `/speckit.tasks` to generate dependency-ordered task breakdown
4. ⏭️ Run `/speckit.implement` to execute implementation tasks

---

**Plan Status**: Phase 0 & 1 in progress (this command execution)
**Author**: Claude Sonnet 4.5
**Last Updated**: 2026-01-02
